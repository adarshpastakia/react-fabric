import{K as f,L as c,cl as l}from"./ShadowCastClear.glsl.js";import{createMesh as u}from"./meshUtils.js";import"./iframe-DwvN93Ge.js";import"./index.js";import"./Viewport.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";import"./debounce.js";import"./index2.js";import"./Mesh.js";import"./MeshComponent.js";import"./meshProperties.js";import"./MeshTransform.js";import"./MeshVertexAttributes.js";import"./triangulationUtils.js";import"./earcut.js";import"./deduplicate.js";import"./vertexSpaceConversion.js";import"./vec4.js";import"./External.js";function q(n,o){const m=new Array,p=f.fromJSON(o.spatialReference);for(const e of o.features){const t=e.metadata,r=c(e.geometry);if(!t||!r){m.push(null);continue}r.spatialReference=p;const a=r.extent,s=u({layerView:n,nodeIndex:t.meta.node.index,featureIndex:t.index,extent:a,spatialReference:p});m.push(s),e.geometry=null}const i=l.fromJSON(o);for(let e=0;e<i.features.length;e++){const t=i.features[e],r=m[e];t.geometry=r}return i}export{q as processQueryGeometries};
