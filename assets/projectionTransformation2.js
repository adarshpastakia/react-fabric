import{t as f,a as c,z as m,b as d,R as g,d as l,J as u,W as x}from"./ProjectionTransformation.js";import"./Point2D.js";import{Envelope2D as I}from"./Envelope2D.js";import"./Transformation2D.js";import"./ShadowCastClear.glsl.js";import"./iframe-qDaPDssc.js";import"./index.js";import"./Viewport.js";import"./debounce.js";import"./index2.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";import"./OperatorDefinitions.js";function L(e,o,t){var s;let a,n;if(t!=null&&t.geographicTransformation){if((s=t.geographicTransformation.steps)!=null&&s.length){const r=new f;r.setInputSpatialReference(e),r.setOutputSpatialReference(o);for(const i of t.geographicTransformation.steps){let p;p=i.wkid?c(i.wkid,i.isInverse):m(i.wkt,i.isInverse),r.add(p)}a=r.create()}else a=u();if(t.extendedParams){n=x();const{densificationStep:r}=t.extendedParams;r!=null&&(n.densificationStep=r)}}else if(t!=null&&t.areaOfInterestExtent)return d(e,o,h(t.areaOfInterestExtent));return a?g(e,o,a,n):l(e,o)}function h(e){return I.construct(e.xmin,e.ymin,e.xmax,e.ymax)}export{L as createProjectionTransformation};
