import{ij as b,d as w,H as k,hG as v,i as d,cf as I,ik as h,il as g,im as S,K as x,io as E,cl as M,ip as O,iq as F}from"./ShadowCastClear.glsl.js";const $={esriGeometryPoint:"points",esriGeometryPolyline:"polylines",esriGeometryPolygon:"polygons"};function H(s){var i;const r=s.folders||[],e=r.slice(),o=new Map,a=new Map,u=new Map,y=new Map,c=new Map,f={esriGeometryPoint:a,esriGeometryPolyline:u,esriGeometryPolygon:y};(((i=s.featureCollection)==null?void 0:i.layers)||[]).forEach(t=>{const p=d(t);p.featureSet.features=[];const l=t.featureSet.geometryType;o.set(l,p);const m=t.layerDefinition.objectIdField;l==="esriGeometryPoint"?G(a,m,t.featureSet.features):l==="esriGeometryPolyline"?G(u,m,t.featureSet.features):l==="esriGeometryPolygon"&&G(y,m,t.featureSet.features)}),s.groundOverlays&&s.groundOverlays.forEach(t=>{c.set(t.id,t)}),r.forEach(t=>{t.networkLinkIds.forEach(p=>{const l=j(p,t.id,s.networkLinks);l&&e.push(l)})}),e.forEach(t=>{var p;if(t.featureInfos){t.points=d(o.get("esriGeometryPoint")),t.polylines=d(o.get("esriGeometryPolyline")),t.polygons=d(o.get("esriGeometryPolygon")),t.mapImages=[];for(const l of t.featureInfos)switch(l.type){case"esriGeometryPoint":case"esriGeometryPolyline":case"esriGeometryPolygon":{const m=f[l.type].get(l.id);m&&((p=t[$[l.type]])==null||p.featureSet.features.push(m));break}case"GroundOverlay":{const m=c.get(l.id);m&&t.mapImages.push(m);break}}t.fullExtent=P([t])}});const n=P(e);return{folders:r,sublayers:e,extent:n}}function J(s,r,e,o){var y;const a=(y=w)==null?void 0:y.findCredential(s);s=b(s,{token:a==null?void 0:a.token});const u=v.kmlServiceUrl;return k(u,{query:{url:s,model:"simple",folders:"",refresh:e!==0||void 0,outSR:JSON.stringify(r)},responseType:"json",signal:o})}function N(s,r,e=null,o=[]){const a=[],u={},y=r.sublayers,c=new Set(r.folders.map(f=>f.id));return y.forEach(f=>{var i;const n=new s;if(e?n.read(f,e):n.read(f),o.length&&c.has(n.id)&&(n.visible=o.includes(n.id)),u[f.id]=n,f.parentFolderId!=null&&f.parentFolderId!==-1){const t=u[f.parentFolderId];t.sublayers||(t.sublayers=[]),(i=t.sublayers)==null||i.unshift(n)}else a.unshift(n)}),a}function G(s,r,e){e.forEach(o=>{s.set(o.attributes[r],o)})}function L(s,r){let e;return r.some(o=>o.id===s&&(e=o,!0)),e}function j(s,r,e){const o=L(s,e);return o&&(o.parentFolderId=r,o.networkLink=o),o}async function T(s,r,e,o){const a=s[r];if(!a)return[];const u=M.fromJSON(a.featureSet).features,y=a.layerDefinition,c=O(y.drawingInfo.renderer),f=F.fromJSON(a.popupInfo),n=[];for(const i of u){const t=await c.getSymbolAsync(i);i.symbol=t,i.popupTemplate=f,i.visible=!0;const p=e.sublayerById.get(o);i.origin=p.origin,n.push(i)}return n}function P(s){var o,a,u,y,c,f;const r=I(h),e=I(h);for(const n of s){if((a=(o=n.polygons)==null?void 0:o.featureSet)!=null&&a.features)for(const i of n.polygons.featureSet.features)g(r,i.geometry),S(e,r);if((y=(u=n.polylines)==null?void 0:u.featureSet)!=null&&y.features)for(const i of n.polylines.featureSet.features)g(r,i.geometry),S(e,r);if((f=(c=n.points)==null?void 0:c.featureSet)!=null&&f.features)for(const i of n.points.featureSet.features)g(r,i.geometry),S(e,r);if(n.mapImages)for(const i of n.mapImages)g(r,i.extent),S(e,r)}return E(e,h)?void 0:{xmin:e[0],ymin:e[1],zmin:e[2],xmax:e[3],ymax:e[4],zmax:e[5],spatialReference:x.WGS84}}export{P as I,N as S,T as b,H as d,J as g};
