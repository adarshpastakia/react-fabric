import{jb as ot,eO as at,fe as $e,bJ as o,ns as lt,m_ as ut,b$ as ct,fW as $,fi as N,go as b,h9 as ae,bP as ht,bI as m,qa as D,fb as ft,qb as oe,fV as ee,bK as Te,bL as J,qc as ve,qd as ce,qe as Le,qf as dt,qg as pt,qh as _t,qi as de,oO as mt,b6 as gt,O as vt,ac as Oe,eY as yt,bj as pe,bo as Ie,bk as Pe,f$ as be,ae as Tt,l as bt,b_ as St,qj as Mt,qk as ke,eH as Be,E as P,F as B,V as wt}from"./ShadowCastClear.glsl.js";import{l as Ae,h as Se}from"./FeatureTileDescriptor.js";import"./iframe-DwvN93Ge.js";import"./index.js";import"./Viewport.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";import"./debounce.js";import"./index2.js";function Rt(i,e,t,s,n,l,r=1){const a=ot(e,n);if(a==null)return!1;if(a===at){if(i===s&&t===l)return!0;const c=t+r;for(let _=t,h=l;_<c;++_,++h)$e(s[h],i[_]);return!0}const u=t+r;for(let c=t,_=l;c<u;++c,++_)a(i[c],0,s[_],0);return!0}let xt=class{constructor(e,t){this._renderCoordsHelper=e,this.opaqueGround=t,this._cache=new Map,this._cameraForward=o(),this._cameraEye=o(),this._cameraFovY=55*Math.PI/180,this._frustumBoundingSphereCenter=o(),this._frustumBoundingSphereRadius=0,this._frustum=new lt(e),this._renderSR=e.spatialReference;const s=ut(this._renderSR);this._renderSREllipsoidRadius=ct(s).radius}setup(e){this._aboveGround=e.aboveGround,this._frustum.update(e),$(this._cameraForward,e.viewForward),$e(this._cameraEye,e.eye),this._cameraFovY=e.fovY,this._updateFrustumBoundingSphere()}done(){this._cache.clear()}compute(e){if(this._cache.has(e.id))return this._cache.get(e.id);const t=this._isVisibleInFrustum(e);return this._cache.set(e.id,t),t}_isVisibleInFrustum(e){return this._renderCoordsHelper.viewingMode===2?this._isTileVisibleInFrustumLocal(e):this._isTileVisibleInFrustumGlobal(e)}_updateFrustumBoundingSphere(){const e=this._frustum,t=e.origin,s=It;$(s,e.direction);const n=e.points,l=Pt;N(l,n[4],t);const r=.5*b(l,l)/b(s,l),a=this._frustumBoundingSphereCenter;ae(a,t,s,r);const u=1+r;this._frustumBoundingSphereRadius=u}_isTileVisibleInFrustumLocal(e){const t=e.spatialReference,s=e.extent,n=this._renderSR;if(!s)return!0;if(S[0]=s[0],S[1]=s[1],S[2]=0,S[3]=s[2],S[4]=s[3],S[5]=0,!ht(S,t,0,S,n,0))return!1;m(G[0],S[0],S[1],0),m(G[1],S[3],S[1],0),m(G[2],S[3],S[4],0),m(G[3],S[0],S[4],0),m(_e,.5*(S[0]+S[3]),.5*(S[1]+S[4]),.5*(S[2]+S[5]));const l=je,r=.5*D(G[0],G[2]),a=this._frustum,u=this._frustumBoundingSphereRadius,c=this._frustumBoundingSphereCenter,_=Bt;N(_,c,_e);const h=b(l,_),y=kt;if(ae(y,_e,l,h),D(y,c)>r+u)return!1;const p=this._cameraForward,q=b(p,je),M=this._cameraFovY,d=this._cameraEye;if(Math.abs(q)<Math.abs(Math.cos(.5*M))){let f=!0;const F=m(cs,p[0],p[1],0),E=b(d,F);for(let L=0;L<4;++L){const U=G[L];if(b(U,F)-E>0){f=!1;break}}if(f)return!1}{const f=G[0],F=G[2];if(f[0]<=d[0]&&d[0]<=F[0]&&f[1]<=d[1]&&d[1]<=F[1])return!0}const g=qt,A=this.opaqueGround&&this._aboveGround,Z=this.opaqueGround&&!this._aboveGround,C=Math.min(Z?ue:1/0,h+u),j=Math.max(A?-ue:-1/0,h-u);for(let f=0;f<4;++f)ae(g[f],G[f],l,C),ae(g[f+4],G[f],l,j);if(We(a.planes,g,8))return!1;if(Me(a.planes,g,8))return!0;for(let f=0;f<4;++f){const F=g[f],E=g[f+4];if(xe(a.planes,F,E))return!0;const L=g[(f+1)%4];if(xe(a.planes,F,L))return!0;const U=g[4+(f+1)%4];if(xe(a.planes,E,U))return!0}if(Y[0][3]=+G[0][0],Y[1][3]=-G[2][0],Y[2][3]=+G[0][1],Y[3][3]=-G[2][1],Y[4][3]=+j,Y[5][3]=-C,Me(Y,a.points)||Me(Y,a.points))return!0;for(let f=0;f<4;++f){const F=d,E=a.points[f+4];if(ze(Y,F,E))return!0;const L=a.points[4+(f+1)%4];if(ze(Y,E,L))return!0}return!1}_isTileVisibleInFrustumGlobal(e){if(e.level<ge)return!0;const t=e.spatialReference,s=e.extent;if(!s||!t)return!0;const n=this.opaqueGround&&this._aboveGround,l=this.opaqueGround&&!this._aboveGround,r=G,a=.5*(s[0]+s[2]);if(m(r[0],s[0],s[1],0),m(r[1],s[2],s[1],0),m(r[2],s[2],s[3],0),m(r[3],s[0],s[3],0),m(r[4],a,s[1],0),m(r[5],a,s[3],0),!Rt(r,t,0,r,this._renderSR,0,6))return!1;const u=r[0][2]>0,c=r[3][2]<0,_=u||c,h=this._renderSREllipsoidRadius;if(_){const R=Gt;Q(R,me,r[0]);const w=Ct;if(Q(w,me,r[1]),u){const T=De,v=r[4],x=Ue;Q(x,v,me),Q(T,x,v);const I=r[0];ee(I,R,T),le(I,h);const W=r[1];ee(W,w,T),le(W,h)}else if(c){const T=De,v=r[5],x=Ue;Q(x,v,me),Q(T,v,x);const I=r[3];ee(I,T,R),le(I,h);const W=r[2];ee(W,T,w),le(W,h)}}const y=_e,p=N(Dt,r[3],r[0]);$(p,p);const q=Te(Ut,r[0],r[3]);J(q,q,.5);const M=-b(q,p),d=Te(Vt,r[0],r[1]);J(d,d,.5);const g=Te(jt,r[2],r[3]);J(g,g,.5);const A=N(zt,g,d);$(A,A);const Z=-(M+b(p,d))/b(p,A);ae(y,d,A,Z),le(y,h);const C=this._frustumBoundingSphereRadius,j=this._frustumBoundingSphereCenter,f=this._frustum,F=f.planes,E=Ft;$(E,y);const L=b(r[0],E)/ve(r[0]),U=f.origin,K=f.points;let X=!1;if(n){{X=!0;const w=$(Ve,U);for(let T=0;T<4;++T){const v=K[4+T],x=N(o(),v,U);$(x,x);const I=ee(o(),w,x);$(I,I);const W=ee(o(),x,I);if($(W,W),b(U,W)>h){X=!1;break}}}if(X&&b(U,E)<h*L-ue)return!1;const R=$(Ve,f.origin);if(b(R,E)<0)return!1;{const w=$(ls,f.direction);if(b(w,E)>us)return!1}}const he=Math.sqrt(1-L*L);if(he>.9)return!0;let te=!1;const se=b(E,j),ie=ve(j);if(ie<=C&&!F.some(R=>ce(R,we)>0)){if(!n)return!0;te=!0}const k=se/ie;if(!te&&se<=0&&-se>C)return!1;const H=C/ie;if(Math.sqrt(1-k*k)*Math.sqrt(1-H*H)-H*k>he)return!1;if(!X&&(r.some(R=>f.intersectsPoint(R))||f.intersectsPoint(y)))return!0;const re=At;N(re,j,we);const ne=b(re,E),qe=Ot;J(qe,E,ne);const st=D(qe,j),Ge=t.isWGS84,ye=e.lij,Ce=Ge&&ye[2]===2**ye[0]-1,Fe=Ge&&ye[2]===0,it=Fe?ss:Ce?es:Qt,rt=Fe?is:Ce?ts:Zt;if(!te){const R=r,w=rs,T=Yt,v=Nt,x=we;for(const I of it){const W=R[I];if(He(T,R[(I+1)%4],W),He(v,x,W),Q(w,v,T),Lt(w,K,1))return!1}}let V=null;if(!n&&ne<1.01*C){const R=2.5*C;if(st>L*R+C)return!1;const w=Wt,T=R/L;for(let v=0;v<4;++v)J(w[v],r[v],T/h);m(w[4],0,0,0),V=w}else{const R=(l?h+ue:ne+C)/L,w=n?h-ue:(ne-C)/L,T=Ht;for(let v=0;v<4;++v){const x=r[v];J(T[v],x,w/h),J(T[v+4],x,R/h)}V=T}if(We(F,V,V.length))return!1;const nt=f.lines,z=Jt,fe=Kt;for(const R of nt){$(fe,R.direction);for(const w of rt){const T=V[w];if($(z,T),Re(fe,z,V,K))return!1;const v=(w+1)%4;if(n){const x=V[v];if(N(z,x,T),$(z,z),Re(fe,z,V,K))return!1}if(l){const x=V[4+w],I=V[4+v];if(N(z,I,x),$(z,z),Re(fe,z,V,K))return!1}}}return!0}};function Q(i,e,t){return ee(i,e,t),$(i,i),i}function He(i,e,t){return N(i,e,t),$(i,i),i}function le(i,e){return J(i,i,e/ve(i)),i}const Ze=[0,1,2,3,5];function Et(i,e,t){for(let s=0;s<t;++s)if(ce(i,e[s])<=0)return!1;return!0}function We(i,e,t){for(const s of Ze)if(Et(i[s],e,t))return!0;return!1}function Me(i,e,t=e.length){for(let s=0;s<t;++s){const n=e[s];let l=!0;for(const r of i)if(ce(r,n)>0){l=!1;break}if(l)return!0}return!1}const ge=2,$t=4;function Lt(i,e,t){for(const s of e)if(b(s,i)<t)return!1;return!0}const qt=[o(),o(),o(),o(),o(),o(),o(),o()],S=[0,0,0,0,0,0],G=[o(),o(),o(),o(),o(),o()],_e=o(),De=o(),Gt=o(),Ct=o(),Ue=o(),Ft=o(),Ot=o(),It=o(),Pt=o(),kt=o(),Bt=o(),we=Le(0,0,0),At=o(),Ht=[o(),o(),o(),o(),o(),o(),o(),o()],Wt=[o(),o(),o(),o(),o()],Dt=o(),Ut=o(),Vt=o(),jt=o(),zt=o(),Yt=o(),Nt=o(),Jt=o(),Kt=o(),Xt=o(),Qt=[0,1,2,3],Zt=[0,1,2,3],es=[0,1,3],ts=[0,1,3],ss=[1,2,3],is=[1,2,3],rs=o();function ns(i,e,t){let s=1/0,n=-1/0;for(const l of t){const r=b(e,l);s=Math.min(s,r),n=Math.max(n,r)}i[0]=s,i[1]=n}function os(i,e,t,s){let n=1/0,l=-1/0;for(const r of s){const a=b(t,r);if(n=Math.min(n,a),l=Math.max(l,a),n<=e&&l>=i)return!1}return!0}const as=[0,0];function Re(i,e,t,s){const n=t.length,l=s.length;if(n===0||l===0)return!0;const r=Xt;Q(r,i,e);const a=l<n,u=a?t:s,c=as;return ns(c,r,a?s:t),os(c[0],c[1],r,u)}const ue=430,Ve=o(),ls=o(),us=Math.cos(.25*Math.PI),je=ft(0,0,1),cs=o();function xe(i,e,t){const s={t0:0,t1:1};for(const n of Ze)if(!et(i[n],e,t,s))return!1;return s.t0<s.t1}function ze(i,e,t){const s={t0:0,t1:1};for(const n of i)if(!et(n,e,t,s))return!1;return s.t0<s.t1}function et(i,e,t,s){let{t0:n,t1:l}=s;const r=ce(i,e),a=ce(i,t);if(r>=0&&a>=0)return!1;if(r<0&&a>=0){const u=-r/(a-r);if(u<n)return!1;u<l&&(l=u)}else if(r>=0&&a<0){const u=r/(r-a);if(u>l)return!1;u>n&&(n=u)}return s.t0=n,s.t1=l,!0}const Y=[oe(-1,0,0,1),oe(1,0,0,-1),oe(0,-1,0,1),oe(0,1,0,-1),oe(0,0,-1,1),oe(0,0,1,-1)],me=Le(0,0,1);class Ye{constructor(e,t,s){this._renderCoordsHelper=e,this._tilingScheme=t,this._camera=new dt,this._surfaceElevation=0,this._focusOnMap=[0,0],this._visibility=new xt(e,s)}set opaqueGround(e){this._visibility.opaqueGround=e}setup(e,t,s){this._camera.copyFrom(e),this._surfaceElevation=s,this._focusOnMap[0]=t.x,this._focusOnMap[1]=t.y,this._visibility.setup(this._camera)}done(){this._visibility.done()}update(e){const{measures:t,extent:s,level:n}=e;s&&(t.visible=this._visibility.compute(e),t.distance=pt(s,this._focusOnMap),t.mergeable=!0,t.lodLevel=ge,t.splitPriority=Math.max(0,ge-n),t.visible&&(this._isGlobal?this._updateSplitAndLodGlobal(e):this._updateSplitAndLodLocal(e)))}_updateSplitAndLodGlobal(e){const t=e.level,s=this._renderCoordsHelper,{eye:n,fov:l}=this._camera,r=s.referenceEllipsoid.radius,a=ve(n)-r;if(2*Math.atan(r/a)<l&&a>0)return void(e.measures.lodLevel=Math.max(t,ge));const u=Ne,{extent:c}=e;if(!c)return;const{_surfaceElevation:_}=this;m(u[0],c[0],c[1],_),m(u[1],c[2],c[1],_),m(u[2],c[2],c[3],_),m(u[3],c[0],c[3],_);const h=m(Je,.5*(c[0]+c[2]),.5*(c[1]+c[3]),_),y=this._tilingScheme.spatialReference;for(let d=0;d<4;++d)s.toRenderCoords(u[d],y,u[d]);s.toRenderCoords(h,y,h);const p=$(Ee.direction,h),q=b(n,p),M=J(Ke,p,q);this._updateSplitAndLod(e,u,h,M)}_updateSplitAndLodLocal(e){const t=Ne,{extent:s}=e;if(!s)return;const{_surfaceElevation:n}=this;m(t[0],s[0],s[1],n),m(t[1],s[2],s[1],n),m(t[2],s[2],s[3],n),m(t[3],s[0],s[3],n);const l=this._tilingScheme.spatialReference;for(let h=0;h<4;++h)this._renderCoordsHelper.toRenderCoords(t[h],l,t[h]);const r=m(Je,.5*(t[0][0]+t[2][0]),.5*(t[0][1]+t[2][1]),.25*(t[0][2]+t[1][2]+t[2][2]+t[3][2])),a=m(hs,r[0],r[1],0),{eye:u,far:c}=this._camera,_=m(Ke,a[0],a[1],u[2]);m(Ee.origin,a[0],a[1],u[2]-2*c),$e(Ee.direction,tt),this._updateSplitAndLod(e,t,r,_)}_updateSplitAndLod(e,t,s,n){const l=Math.max(D(t[0],t[2]),D(t[1],t[3]),D(t[0],s)+D(s,t[2]),D(t[1],s)+D(s,t[3])),{eye:r,near:a,fov:u,viewForward:c,width:_,height:h,pixelRatio:y,frustum:p}=this._camera,q=b(r,c),M=b(s,c)-q,d=D(s,r);let g=M,A=M,Z=d,C=d;const j=(k,H)=>H<a?1:Math.sqrt(k*k-H*H)/H;let f=j(d,M);for(const k of t){const H=b(k,c)-q;g=Math.min(g,H),A=Math.max(A,H);const re=D(k,r);C=Math.max(C,re),Z=Math.min(Z,re);const ne=j(re,H);f=Math.min(f,ne)}if(A<a)return void(e.measures.lodLevel=0);const F=Math.cos(.5*u),E=D(r,n);f>F&&E>ds*l&&(A=Xe*C,g=Xe*Z);const L=.5*Math.sqrt(_*_+h*h)/y,U=2*Math.tan(.5*u),K=k=>Math.max(a,k)*fs/L*U,X=e.level,he=l*2**X*Math.max(1,U),te=K(g),se=Math.ceil(Math.log2(Math.max(1,he/te)));if(e.measures.lodLevel=Math.max(se,e.measures.lodLevel),e.measures.splitPriority+=e.measures.lodLevel-X,X<se){const k=+de(p,t[0])+ +de(p,t[1])+ +de(p,t[2])+ +de(p,t[3]);e.measures.splitPriority+=k}const ie=K(A)/te;ie>2.5&&(e.measures.splitPriority+=ie)}get _isGlobal(){return this._renderCoordsHelper.viewingMode===1}}const Ne=[o(),o(),o(),o()],Je=o(),hs=o(),Ke=o(),tt=Le(0,0,1),Ee=_t(mt,tt),fs=312,ds=.5,Xe=2,ps=60;let O=class extends gt{constructor(i){super(i),this.tiles=new vt,this.tileSize=512,this._idToTile=new Map,this._dirty=Oe(!1),this._pendingTiles=Oe(null),this._newTiles=new yt,this._tests=!1,this._measurements=new Ye(i.renderCoordsHelper,i.terrain.tilingScheme,this._opaqueGround)}initialize(){var i;this.addHandles([pe(()=>this.tileSize,()=>this._reset(),Ie),pe(()=>{var e,t,s,n;return[(e=this.pointsOfInterest.cameraOnSurface)==null?void 0:e.location,(t=this.viewState)==null?void 0:t.contentCamera,(s=this.pointsOfInterest.focus)==null?void 0:s.location,((n=this.terrain)==null?void 0:n.baseOpacity)??1]},()=>this._setDirty(),Ie),pe(()=>this.tilingScheme,e=>{this._reset(),this._measurements=new Ye(this.renderCoordsHelper,e,this._opaqueGround)},Pe),pe(()=>this._opaqueGround,e=>this._measurements.opaqueGround=e,Pe)]),this._frameWorker=(i=this.scheduler)==null?void 0:i.registerTask(be.FEATURE_TILE_TREE,this)}destroy(){this._frameWorker=Tt(this._frameWorker),this._measurements=null,this._newTiles.prune()}get tilingScheme(){var i;return(i=this.terrain.tilingScheme)==null?void 0:i.clone()}set filterExtent(i){if(i!=null&&!i.spatialReference.equals(this.viewState.spatialReference))return void bt.getLogger(this).error("#extent","extent spatial reference needs to be in the same spatial reference as the view");const e=this._get("filterExtent");if(e===i||e!=null&&i&&e.equals(i))return;const t=i!=null?i.clone():null;this._set("filterExtent",t),this._setDirty()}get _filterExtentRect(){if(this.filterExtent==null)return null;const i=St();return Mt(this.filterExtent,i,this.tilingScheme.spatialReference),i}get _rootTileIds(){const{tilingScheme:i}=this;return this._filterExtentRect&&i?i.rootTilesInExtent(this._filterExtentRect):[[0,0,0]]}set suspended(i){i!==this._get("suspended")&&(this._set("suspended",i),this._setDirty())}get updating(){return this._dirty.value||!!this._pendingTiles.value}get _opaqueGround(){var i;return(((i=this.terrain)==null?void 0:i.baseOpacity)??1)===1}_setDirty(){this.suspended||(this._frameWorker?this._dirty.value=!0:this.runTask(ke))}_clear(){this.tiles.removeAll(),this._idToTile.clear(),this._reset(!1),this._dirty.value=!1}get readyToRun(){return this.updating}_reset(i=!0){this._newTiles.clear(),this._pendingTiles.value=null,i&&this._setDirty()}_getRootTiles(){const i=this.tilingScheme;return this._rootTileIds.map(e=>new Ae(e[0],e[1],e[2],i))}runTask(i){i=this._tests?ke:i,this._dirty.value=!1,this._pendingTiles.value||(this._startUpdate(i),this._frameWorker!=null&&(this._frameWorker.priority=be.FEATURE_TILE_TREE_ACTIVE)),this._splitPendingTiles(i),this._pendingTiles.value||this._frameWorker==null||(this._frameWorker.priority=be.FEATURE_TILE_TREE)}_startUpdate(i){if(this.suspended)return;if(!this.tilingScheme)return void this._clear();const{_measurements:e,_filterExtentRect:t,_newTiles:s}=this;e.setup(this.viewState.contentCamera,this.pointsOfInterest.focus.location,this.pointsOfInterest.cameraOnSurface.location.z??0),this._pendingTiles.value=this._getRootTiles().filter(n=>{if(e.update(n),n.measures.visible&&(!t||!n.extent||Be(n.extent,t))){if(n.measures.splitPriority>0)return!0;s.push(n)}return!1}).sort(Qe),this._newTiles.clear(),i.madeProgress()}_splitPendingTiles(i){const e=this._pendingTiles.value;if(!e)return;const{tilingScheme:t,_filterExtentRect:s,_newTiles:n,_measurements:l}=this;for(;e.length>0&&this._tileBudgetRatio<=2;){const r=e.pop();if(i.madeProgress(),r.measures.splitPriority>0){t.ensureMaxLod(r.level+1);const a=r.createChildren();for(const u of a)l.update(u),!u.measures.visible||s&&u.extent&&!Be(u.extent,s)||(u.measures.splitPriority>0?e.push(u):n.push(u));e.sort(Qe),this._mergeNewTiles(2),this._mergeNewTiles(2,!0)}else n.push(r);if(i.done)return}n.pushArray(e),this._pendingTiles.value=null,this._updateTiles(),n.clear(),l.done()}get _tileBudgetRatio(){var i;return(this._newTiles.length+(((i=this._pendingTiles.value)==null?void 0:i.length)??0))/ps}_mergeNewTiles(i,e=!1){if(this._tileBudgetRatio<=i)return;const{_newTiles:t,_measurements:s}=this;t.sort((r,a)=>a.measures.distance-r.measures.distance);const n=new Map(t.map(r=>[r.id,r])),l=t.length;for(const r of n.values()){const{lij:a,measures:u}=r;if(!u.mergeable||a[1]%2!=0||a[2]%2!=0||a[0]<=1||r.lodLevelDelta>=$t)continue;const c=u.lodLevel;let _=c,h=!0;const y=n.get(Se(a[0],a[1]+1,a[2]));let p=Math.abs(((y==null?void 0:y.measures.lodLevel)??0)-c),q=p===0||e&&(y==null?void 0:y.measures.mergeable)&&p<=1;if(!y||!q)continue;_+=y.measures.lodLevel,h&&(h=p===0);const M=n.get(Se(a[0],a[1],a[2]+1));if(p=Math.abs(((M==null?void 0:M.measures.lodLevel)??0)-c),q=p===0||e&&(M==null?void 0:M.measures.mergeable)&&p<=1,!M||!q)continue;_+=M.measures.lodLevel,h&&(h=p===0);const d=n.get(Se(a[0],a[1]+1,a[2]+1));if(p=Math.abs(((d==null?void 0:d.measures.lodLevel)??0)-c),q=p===0||e&&(d==null?void 0:d.measures.mergeable)&&p<=1,!d||!q)continue;_+=d.measures.lodLevel,h&&(h=p===0),t.removeUnordered(r),t.removeUnordered(y),t.removeUnordered(M),t.removeUnordered(d),n.delete(r.id),n.delete(y.id),n.delete(M.id),n.delete(d.id);const g=new Ae(a[0]-1,a[1]/2,a[2]/2,this.tilingScheme);if(s.update(g),g.measures.visible=!0,g.measures.lodLevel=_/4,g.measures.mergeable=h,t.push(g),n.set(g.id,g),this._tileBudgetRatio<=i)return}t.length<l&&this._mergeNewTiles(i,e)}_updateTiles(){this._mergeNewTiles(1),this._mergeNewTiles(1,!0);for(const s of this.tiles.items)s.used=!1;let i=!1;const e=this._newTiles.filter(s=>{const n=this._idToTile.get(s.id);return n?(i||(i=n.measures.lodLevel!==s.measures.lodLevel),n.measures={...s.measures},n.used=!0):this._idToTile.set(s.id,s),!n}),t=this.tiles.items.filter(s=>!s.used&&(this._idToTile.delete(s.id),!0));this.tiles.removeMany(t),this.tiles.addMany(e),this._sortTiles(),!i||t.length||e.length||this.tiles.emit("change")}_sortTiles(){this.viewState.fixedContentCamera||this.tiles.sort((i,e)=>i.measures.distance-e.measures.distance),this.tiles.forEach((i,e)=>i.loadPriority=e)}};function Qe(i,e){return i.lodLevelDelta-e.lodLevelDelta||i.measures.splitPriority-e.measures.splitPriority||e.measures.distance-i.measures.distance}P([B({constructOnly:!0})],O.prototype,"scheduler",void 0),P([B({constructOnly:!0})],O.prototype,"renderCoordsHelper",void 0),P([B({constructOnly:!0})],O.prototype,"pointsOfInterest",void 0),P([B({constructOnly:!0})],O.prototype,"viewState",void 0),P([B({constructOnly:!0})],O.prototype,"terrain",void 0),P([B()],O.prototype,"tiles",void 0),P([B()],O.prototype,"tileSize",void 0),P([B({readOnly:!0})],O.prototype,"tilingScheme",null),P([B()],O.prototype,"filterExtent",null),P([B({readOnly:!0})],O.prototype,"_filterExtentRect",null),P([B({readOnly:!0})],O.prototype,"_rootTileIds",null),P([B({value:!1})],O.prototype,"suspended",null),P([B({readOnly:!0})],O.prototype,"updating",null),O=P([wt("esri.views.3d.layers.support.FeatureTileTree3D")],O);export{O as FeatureTileTree3D};
