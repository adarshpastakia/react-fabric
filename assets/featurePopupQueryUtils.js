import{eK as M,eL as B,eM as O,a2 as $}from"./ShadowCastClear.glsl.js";async function L(n,r,s,i){var I,m,q;const l=new Array(r.length),a=new Map,c=new Map,b=M(n.fieldsIndex,s.outFields),F=((m=(I=n.capabilities)==null?void 0:I.operations)==null?void 0:m.supportsQuery)===!0&&n.queryFeatures!=null,A=(i==null?void 0:i.hasRequiredFields)??B;for(let e=0;e<r.length;e++){const t=r[e];if(F&&!t.isAggregate){if(s.returnGeometry||!A(t,b)){const u=t.getObjectId();if(u!=null){a.set(u,{graphic:t,index:e});continue}const f=t.getGlobalId();if(f!=null){c.set(f,{graphic:t,index:e});continue}}l[e]=t}else l[e]=t}if(!F||!n.queryFeatures||a.size===0&&c.size===0)return l.filter(Boolean);const p=[],h=(e,t)=>{t&&(e.outFields??(e.outFields=[]),e.outFields.includes(t)||e.outFields.push(t))};if(a.size>0){const e=s.clone();h(e,n.objectIdField),"uniqueIdFields"in n&&((q=n.uniqueIdFields)!=null&&q.length)&&(e.outFields??(e.outFields=[]),e.outFields.push(...n.uniqueIdFields)),e.objectIds=Array.from(a.keys()),p.push({type:"object-id",query:e,map:a})}const y="globalIdField"in n?n.globalIdField:null;if(y!=null&&c.size>0){const e=s.clone();h(e,y);const t=Array.from(c.keys());e.where=O(s.where,`${y} IN (${t.map(u=>`'${u}'`).join(",")})`),p.push({type:"global-id",query:e,map:c})}const w=(i==null?void 0:i.updateSourceAttributes)??!1;for(const{type:e,query:t,map:u}of p)try{const f=await n.queryFeatures(t,i);for(const o of f.features){const j=e==="object-id"?o.getObjectId():o.getGlobalId();if(j==null)continue;const x=u.get(j);if(!x)continue;const{graphic:d,index:z}=x;if(w&&o.attributes){d.attributes??(d.attributes={});for(const g of b)g in o.attributes&&(d.attributes[g]=o.attributes[g])}const{geometry:k,origin:G}=d;o.geometry||(o.geometry=k),o.origin=G,l[z]=o}}catch{}return l.filter(Boolean)}async function N(n){var r;if((r=n.expressionInfos)!=null&&r.length||Array.isArray(n.content)&&n.content.some(s=>s.type==="expression"))return $()}export{L as n,N as s};
