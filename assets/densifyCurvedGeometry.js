import{cO as z,cT as I,cU as b,cV as H,cW as w,cX as F,cY as O,cZ as T,c_ as U,c$ as l,d0 as V,d1 as f,d2 as m,d3 as W,d4 as X}from"./ShadowCastClear.glsl.js";const v={maxSegmentLength:1/0,maxDeviation:1/0,maxSegmentsPerCurve:12e3,minSegmentsPerCurve:1},g=1e-6,Y=[0,0];function j(t){return{maxSegmentLength:t.maxSegmentLength??v.maxSegmentLength,maxDeviation:t.maxDeviation??v.maxDeviation,maxSegmentsPerCurve:t.maxSegmentsPerCurve??v.maxSegmentsPerCurve,minSegmentsPerCurve:Math.max(t.minSegmentsPerCurve??v.minSegmentsPerCurve,1)}}class D{constructor(s,n){this.curveStart=s,this.curveEnd=n,this.tStart=0,this.tEnd=0,this.tEndStack=[],this.arcEndStack=[]}get stackSize(){return this.tEndStack.length}initialize(s,n){this.tStart=0,this.arcStart=s,this.tEndStack.push(1),this.arcEndStack.push(n)}splitAt(s){this.tEndStack.push(this.tEnd),this.arcEndStack.push(this.arcEnd),this.tEndStack.push(s),this.arcEndStack.push(this.interpolate(s))}splitInHalf(){return this.splitAt((this.tStart+this.tEnd)/2)}pop(){this.tEnd=this.tEndStack.pop(),this.arcEnd=this.arcEndStack.pop()}next(){this.tStart=this.tEnd,this.arcStart=this.arcEnd}densify(s,{maxDeviation:n,maxSegmentLength:i,maxSegmentsPerCurve:e,minSegmentsPerCurve:a}){const h=i*i,r=n*n,o=1/e,c=this.interpolate(0),u=this.interpolate(1);m(this.curveStart,c)>g&&s.push(c),this.initialize(c,u);const S=1/a;for(let p=a-1;p>0;p--){const d=p*S;this.pop(),this.splitAt(d)}for(;this.stackSize>0;)this.pop(),this.tStart===this.tEnd||this.tEnd-this.tStart<o||(h===0||!isFinite(h)||m(this.arcStart,this.arcEnd)<h)&&(r===0||!isFinite(r)||this.getDeviation2()<r)?(s.push(this.arcEnd),this.next()):this.splitInHalf();return m(this.curveEnd,u)>g&&s.push([...this.curveEnd]),s}}class q extends D{constructor(s,n){const[i,e,a]=n.b;super(s,i),this._controlPointsStack=[],this._curveControlPoints=[e,a],this._arcControlPoints=[e,a],this._controlPointsStack.push(this._arcControlPoints)}splitAt(s){const{arcStart:n,arcEnd:i,tStart:e,tEnd:a}=this,[h,r]=this._arcControlPoints,o=(s-e)/(a-e),c=l([],n,h,o),u=l(Y,h,r,o),S=l([],r,i,o),p=l([],c,u,o),d=l([],u,S,o),E=l([],p,d,o);this.tEndStack.push(this.tEnd),this.arcEndStack.push(this.arcEnd),this._controlPointsStack.push([d,S]),this.tEndStack.push(s),this.arcEndStack.push(E),this._arcControlPoints[0]=c,this._arcControlPoints[1]=p,this._controlPointsStack.push(this._arcControlPoints)}pop(){super.pop(),this._arcControlPoints=this._controlPointsStack.pop()}interpolate(s){const{curveStart:n,curveEnd:i}=this,[e,a]=this._curveControlPoints;return V(n,e,a,i,s)}getDeviation2(){const{arcStart:s,arcEnd:n}=this,[i,e]=this._arcControlPoints;return Math.max(f(i,s,n),f(e,s,n))}}class B extends D{constructor(s,n){const[i]=n.a;super(s,i),this._derivedEllipse=W(s,n)}pop(){super.pop(),this._tMid=(this.tStart+this.tEnd)/2,this._arcMid=this.interpolate(this._tMid)}splitInHalf(){this.tEndStack.push(this.tEnd),this.arcEndStack.push(this.arcEnd),this.tEndStack.push(this._tMid),this.arcEndStack.push(this._arcMid)}interpolate(s){return X(this._derivedEllipse,s)}getDeviation2(){return f(this._arcMid,this.arcStart,this.arcEnd)}}function Z(t,s,n,{cx:i,cy:e,radius:a,thetaStart:h,thetaEnd:r,isInvalid:o},{maxDeviation:c,maxSegmentLength:u,maxSegmentsPerCurve:S,minSegmentsPerCurve:p}){if(o)return t.push([...n]),t;const d=2*a,E=[i+a*Math.cos(h),e+a*Math.sin(h)],x=[i+a*Math.cos(r),e+a*Math.sin(r)];m(s,E)>g&&t.push(E);const M=Math.abs(r-h),L=u<d?2*Math.asin(u/d):M,y=c<=a?2*Math.acos(1-c/a):M,A=Math.min(L,y),k=Math.min(S,Math.max(p,Math.ceil(Math.abs(M/A)))),R=1/k;for(let P=1;P<k;P++){const _=P*R,C=h*(1-_)+r*_;t.push([i+a*Math.cos(C),e+a*Math.sin(C)])}return t.push(x),m(n,x)>g&&t.push([...n]),t}function G(t,s,n,i){return new q(s,n).densify(t,i)}function J(t,s,n,i){const e=T(s,n),[a]=n.c;return Z(t,s,a,e,i)}function K(t,s,n,i){const e=U(s,n),[a]=n.a;return Z(t,s,a,e,i)}function N(t,s,n,i){const[e,a,h,r,o,c,u]=n.a;return c===0||u===0?(t.push([...e]),t):new B(s,n).densify(t,i)}function Q(t,s,n,i){return H(n)?(t.push([...n]),t):w(n)?G(t,s,n,i):F(n)?J(t,s,n,i):O(n)?K(t,s,n,i):N(t,s,n,i)}function tt(t,s){if(!z(t))return t;const n=j(s),i=I(t),e=[];for(const a of i){const h=[];for(let r=0;r<a.length-1;r++){const o=r+1,c=[...b(a[r])];r===0&&h.push(c),Q(h,c,a[o],n)}e.push(h)}return"curvePaths"in t?{...t.hasZ!==void 0?{hasZ:t.hasZ}:{},...t.hasM!==void 0?{hasM:t.hasM}:{},paths:e,spatialReference:t.spatialReference}:{...t.hasZ!==void 0?{hasZ:t.hasZ}:{},...t.hasM!==void 0?{hasM:t.hasM}:{},rings:e,spatialReference:t.spatialReference}}export{tt as y};
