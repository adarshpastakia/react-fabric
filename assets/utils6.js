import{aa as l}from"./ShadowCastClear.glsl.js";import{a as w,f as L}from"./loadUtils2.js";function W(n){const e=_($(n)),t=e,s=!0,i=Math.max(e/2,5),a=Math.round(l(n.maxPathLength)/i)+1,m=10,{density:f}=n;return{smoothing:l(n.smoothing),interpolate:!0,velocityScale:n.flowRepresentation==="flow-from"?1:-1,verticesPerLine:a,minSpeedThreshold:.001,segmentLength:i,maxTurnAngle:1,collisions:s,lineCollisionWidth:t,lineSpacing:m,density:f,onlyForwardTracing:!0,wrapAround:!1}}function _(n){return n.kind==="constant"?n.value[0]:n.values[n.values.length-1]}function T(n){const e=n.toRgba();return[e[0]/255,e[1]/255,e[2]/255,e[3]]}function C(n){return{kind:"constant",value:[.1,.1,.1,1]}}function $(n){if(!n.hasVisualVariables("size"))return{kind:"constant",value:[l(n.trailWidth)]};const e=n.getVisualVariablesForType("size")[0],t=[],s=[];let i;if(e.stops){for(const a of e.stops)t.push(a.value),s.push(l(a.size));i=e.stops.length}else t.push(e.minDataValue,e.maxDataValue),s.push(l(e.minSize),l(e.maxSize)),i=2;return{kind:"ramp",stops:t,values:s,count:i}}function D(n){if(!n.hasVisualVariables("color"))return{kind:"constant",value:T(n.color)};const e=n.getVisualVariablesForType("color")[0],t=[],s=[];for(const i of e.stops)t.push(i.value),Array.prototype.push.apply(s,T(i.color));return{kind:"ramp",stops:t,values:s,count:e.stops.length}}function E(n){if(!n.hasVisualVariables("opacity"))return{kind:"constant",value:[1]};const e=n.getVisualVariablesForType("opacity")[0],t=[],s=[];for(const i of e.stops)t.push(i.value),s.push(i.opacity);return{kind:"ramp",stops:t,values:s,count:e.stops.length}}function S(n,e,t,s){switch(e){case"int":n.setUniform1iv(t,s);break;case"float":n.setUniform1fv(t,s);break;case"vec2":n.setUniform2fv(t,s);break;case"vec3":n.setUniform3fv(t,s);break;case"vec4":n.setUniform4fv(t,s)}}function I(n,e,t,s){s.kind==="constant"?S(n,t,`u_${e}`,s.value):(S(n,"float",`u_${e}_stops`,s.stops),S(n,t,`u_${e}_values`,s.values),n.setUniform1i(`u_${e}_count`,s.count))}function F(n,e){let t=!0;return t=t&&n.collisions===e.collisions,t=t&&n.density===e.density,t=t&&n.interpolate===e.interpolate,t=t&&n.lineCollisionWidth===e.lineCollisionWidth,t=t&&n.lineSpacing===e.lineSpacing,t=t&&n.maxTurnAngle===e.maxTurnAngle,t=t&&n.minSpeedThreshold===e.minSpeedThreshold,t=t&&n.segmentLength===e.segmentLength,t=t&&n.smoothing===e.smoothing,t=t&&n.velocityScale===e.velocityScale,t=t&&n.verticesPerLine===e.verticesPerLine,t}function M(n,e){return n===e||n!=null&&e!=null&&n.equals(e)}function R(n,e){if(!F(n.simulationSettings,e.simulationSettings)||!M(n.timeExtent,e.timeExtent))return!1;let t=!0;return t=t&&n.loadImagery===e.loadImagery,t=t&&n.createFlowMesh===e.createFlowMesh,t=t&&n.color.kind===e.color.kind,t=t&&n.opacity.kind===e.opacity.kind,t=t&&n.size.kind===e.size.kind,t}function U(n,e,t,s){return n/=t.size[0],e=1-(e/=t.size[1]),n*=t.extent.xmax-t.extent.xmin,e*=t.extent.ymax-t.extent.ymin,n+=t.extent.xmin,e+=t.extent.ymin,n-=s.extent.xmin,e-=s.extent.ymin,n/=s.extent.xmax-s.extent.xmin,e=1-(e/=s.extent.ymax-s.extent.ymin),{x:n*=s.size[0],y:e*=s.size[1]}}function q(n,e,t,s){const i=[],a=t.time-e.time;if(n.length===0)return[];const m=w(n),f=m?L(n[0].hasMagnitude):1,g=m?({vertices:o},u)=>{const c=o,r=u*f;return{x:c[r],y:c[r+1],t:c[r+2],speed:0}}:({vertices:o},u)=>o[u];for(const o of n){const{stage:u,vertices:c}=o;if(u===2)continue;const r=c.length/f,p=g(o,0),v=p.t,b=(a*s-v)%(g(o,r-1).t-v)+v;let h,y=p.x,k=p.y,x=p.t;for(h=1;h<r&&x<b;h++){const d=g(o,h),V=Math.min(d.t,b)-x,z=d.t-x;y+=(d.x-y)*(V/z),k+=(d.y-k)*(V/z),x+=V}i.push(U(y,k,e,t))}return i}export{C as a,M as f,R as h,W as i,D as l,I as m,_ as o,F as p,$ as r,E as u,q as x};
