const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./densifyOperator.js","./ShadowCastClear.glsl.js","./iframe-DpfJK_wQ.js","./iframe-DPR8S5X3.css","./index.js","./Viewport.js","./debounce.js","./index2.js","./Section.js","./ErrorBoundary.js","./createClass.js","./Global.js","./useIsDark.js","./ShadowCastClear-BxU8WlBI.css","./Point2D.js","./ProjectionTransformation.js","./Envelope2D.js","./Transformation2D.js","./OperatorDefinitions.js","./jsonConverter.js","./operatorDensify.js","./apiConverter.js","./differenceOperator.js","./lengthOperator2.js"])))=>i.map(i=>d[i]);
import{b6 as Z}from"./iframe-DpfJK_wQ.js";import{D as Pe,jS as ee,ri as Ie,l as re,b as J,e4 as K,a5 as P,b0 as U,H as Re,jT as De,K as be,af as Be,E as I,F as b,av as we,V as le,cl as Ce,b2 as ze,jR as He,J as $e,at as Je,a4 as Ne}from"./ShadowCastClear.glsl.js";import{y as Se,C as Ee,s as Me,r as Oe,p as ve,g as We,v as ue,U as Le,D as qe,b as Ae}from"./multidimensionalUtils.js";import{u as Ge,N as he,p as je,l as Ve,d as Ue,j as Qe,D as me,h as Xe,a as Ke,b as Ye,q as Ze,W as et,z as tt,B as fe,c as it,i as de}from"./RasterJobHandlerMixin.js";import{R as nt,l as rt,k as st,O as at,a as ot}from"./RasterSymbolizer.js";import{t as O,n as lt}from"./datasetUtils.js";import{QueueProcessor as ct}from"./QueueProcessor.js";import{i as ut,m as ht,h as mt,x as ft,s as dt}from"./RawBlockCache.js";import{g as pt}from"./pixelRangeUtils.js";import{T as ie,N as _e,D as yt,a as xt,l as gt}from"./vectorFieldUtils.js";import{$ as X,j as se,W as pe,f as ye,c as It,n as ne,H as Y,r as Rt,i as bt,C as wt,Q as ae}from"./rasterProjectionHelper.js";import{r as oe,p as St}from"./clipUtils.js";import{T as vt}from"./rasterFunctionHelper.js";const xe=8,_t=256;let Tt=0,v=class extends Pe{constructor(){super(...arguments),this._tileFetchQueue=new ct({concurrency:32,process:(t,n)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:n})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:ee.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,n=X(t.spatialReference);return n!=null&&t.extent.width>=n/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var n,a;this._set("rasterJobHandler",t),O(this)&&((a=(n=this.primaryRasters)==null?void 0:n.rasters)==null||a.forEach(e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+Tt++}set url(t){this._set("url",Ie(t,re.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=se().then(()=>this._open(t))),this._openPromise}async fetchTile(t,n,a,e={}){const i=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(t,n,a,i);if(!s)throw new J("imagery-tile:out-of-bounds","Level for fetch tile out of range");return e={noClip:!0,...e},this.fetchPixels(s,i.size[0],i.size[1],e)}async identify(t,n={}){var N;t=K(P,t).clone().normalize();const{multidimensionalDefinition:a,timeExtent:e}=n,{rasterInfo:i}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:r}=i;let{transposedVariableName:c}=n;const l=r!=null&&s&&(e!=null||Se(a));l&&!c&&(c=a!=null&&a.length>0?a[0].variableName??void 0:r.variables[0].name,n={...n,transposedVariableName:c}),n=this._getRequestOptionsWithSliceId(n);const{spatialReference:o,extent:u}=i,{datumTransformation:h}=n;let m=pe(t,o,h);if(!u.intersects(m))return{location:m,value:null};if(i.transform!=null){const z=i.transform.inverseTransform(m);if(!i.nativeExtent.intersects(z))return{location:z,value:null};m=z}let p=0;const x=c!=null&&r!=null&&i.hasMultidimensionalTranspose;if(O(this)){const z=this.primaryRasters.rasters[0];if(x)return z.identify(m,n);const{pixelSize:E}=i,_=3,W=E.x*_/2,L=E.y*_/2,q=new U({xmin:m.x-W,xmax:m.x+W,ymin:m.y-L,ymax:m.y+L,spatialReference:o}),D={interpolation:"nearest",multidimensionalDefinition:a,sliceId:n.sliceId,bandIds:n.bandIds},{pixelBlock:k}=await z.fetchPixels(q,_,_,D),{pixelBlock:F}=await this.fetchPixels(q,_,_,D);if(k==null)return{location:m,value:null};const B=Math.floor(_*_*.5),A=!k.mask||k.mask[B]?k.pixels.map(C=>C[B]):null;let H;return F!=null&&(H=!F.mask||F.mask[B]?F.pixels.map(C=>C[B]):void 0),{location:m,value:A,processedValue:H,pyramidLevel:0}}if(!x){if(n.srcResolution)p=ye(n.srcResolution,i,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(t,n),p==null)return{location:m,value:null}}const g=this.identifyPixelLocation(m,p,null,x);if(g===null)return{location:m,value:null};const{row:d,col:f,rowOffset:R,colOffset:w,blockWidth:S}=g,T=await this._tileFetchQueue.push({pyramidLevel:p,row:d,col:f,options:n},{signal:n.signal});if(!((N=T==null?void 0:T.pixels)!=null&&N.length))return{location:m,value:null};const $=R*S+w;return this._processIdentifyResult(T,{srcLocation:m,position:$,pyramidLevel:p,useTransposedTile:!!x,requestSomeSlices:l,identifyOptions:n})}async fetchPixels(t,n,a,e={}){t=It(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:i}=this;if(e.requestRawData&&i)return this._fetchPixels(t,n,a,e);const s=X(t.spatialReference),r=ne(t);if(s==null||r===0||r===1&&this._isGlobalWrappableSource&&i)return this._fetchPixels(t,n,a,e);if(r>=3)return{extent:t,pixelBlock:null};const c=[],{xmin:l,xmax:o}=t,u=Math.round(s/(o-l)*n),h=u-Math.round((s/2-l)/(o-l)*n);let m=0;const p=[];for(let f=0;f<=r;f++){const R=new U({xmin:f===0?l:-s/2,xmax:f===r?o-s*f:s/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),w=f===0?u-h:f===r?n-m:u;m+=w,p.push(w);const S=e.disableWrapAround&&f>0?null:this._fetchPixels(R,w,a,e);c.push(S)}const x=(await Promise.all(c)).map(f=>f==null?void 0:f.pixelBlock);let g=null;const d={width:n,height:a};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:x,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},e)).pixelBlock:g=ie(x,d,{blockWidths:p}),{extent:t,srcExtent:Y(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:g}}async fetchRawPixels(t,n,a,e={}){n={x:Math.floor(n.x),y:Math.floor(n.y)};const i=await this._fetchRawTiles(t,n,a,e),{nativeExtent:s,nativePixelSize:r,storageInfo:c}=this.rasterInfo,l=2**t,o=r.x*l,u=r.y*l,h=new U({xmin:s.xmin+o*n.x,xmax:s.xmin+o*(n.x+a.width-1),ymin:s.ymax-u*(n.y+a.height-1),ymax:s.ymax-u*n.y,spatialReference:s.spatialReference});if(!i)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:m,mosaicSize:p}=i;if(m.length===1&&m[0]!=null&&m[0].width===a.width&&m[0].height===a.height)return{extent:h,srcExtent:h,pixelBlock:i.pixelBlocks[0]};const x=t>0?c.pyramidBlockWidth:c.blockWidth,g=t>0?c.pyramidBlockHeight:c.blockHeight,d={x:n.x%x,y:n.y%g};let f;return this.rasterJobHandler?f=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:m,srcMosaicSize:p,destDimension:a,clipOffset:d,clipSize:a,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:f=ie(m,p,{clipOffset:d,clipSize:a}),{extent:h,srcExtent:h,pixelBlock:f}}fetchRawTile(t,n,a,e){throw new J("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Y(this.rasterInfo.extent,t)}decodePixelBlock(t,n){return!this.rasterJobHandler||n.useCanvas?nt(t,n):this.rasterJobHandler.decode({data:t,options:n})}async request(t,n,a=0){const{customFetchParameters:e}=this.ioConfig,{range:i,query:s,headers:r}=n;a=a??n.retryCount??this.ioConfig.retryCount;const c=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await Re(t,{...n,query:{...s,...e},headers:{...r,...c}})}catch(l){if(a>0)return a--,this.request(t,n,a);throw l}}getSliceIndex(t){const{multidimensionalInfo:n}=this.rasterInfo;return n==null||t==null||t.length===0?null:Ee(t,n)}getTileExtentFromTileInfo(t,n,a,e){const i=e.lodAt(t);return i?this.getTileExtent({x:i.resolution,y:i.resolution},n,a,e.origin,e.spatialReference,e.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:n,extent:a,pixelSize:e}=this.rasterInfo,{pyramidResolutions:i}=t;if(!t.tileInfo){const s=[],r=t.maximumPyramidLevel||0;let c=(e.x+e.y)/2,l=1/.0254*96*c;for(let u=0;u<=r&&(s.unshift(new De({level:r-u,resolution:c,scale:l})),u!==r);u++)if(i){const h=(i[u].x+i[u].y)/2;l*=h/c,c=h}else c*=2,l*=2;const o=new P({x:a.xmin,y:a.ymax,spatialReference:n});t.tileInfo=new ee({origin:o,size:[t.blockWidth,t.blockHeight],spatialReference:n,lods:s}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,n=512,a=512,e){const{width:i,height:s,nativeExtent:r,pixelSize:c,spatialReference:l}=t,o=new P({x:r.xmin,y:r.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(i,s))/Math.LN2-8)));const u=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[c],e);t.storageInfo=new rt({blockWidth:n,blockHeight:a,pyramidBlockWidth:n,pyramidBlockHeight:a,origin:o,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,n={}){return 0}computeBlockBoundary(t,n,a,e,i,s=0,r=2){if(i.length===1&&s>0){i=[...i];let{x:u,y:h}=i[0];for(let m=0;m<s;m++)u*=r,h*=r,i.push({x:u,y:h})}const c=[],{x:l,y:o}=e;for(let u=0;u<i.length;u++){const{x:h,y:m}=i[u];c.push({minCol:Math.floor((t.xmin-l+.1*h)/n/h),maxCol:Math.floor((t.xmax-l-.1*h)/n/h),minRow:Math.floor((o-t.ymax+.1*m)/a/m),maxRow:Math.floor((o-t.ymin-.1*m)/a/m)})}return c}getPyramidPixelSize(t){const{nativePixelSize:n}=this.rasterInfo,{pyramidResolutions:a,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return n;if(a!=null&&a.length)return a[t-1];const i=e**t;return{x:n.x*i,y:n.y*i}}identifyPixelLocation(t,n,a,e){const{spatialReference:i,nativeExtent:s,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:c,origin:l,transposeInfo:o}=r,u=e&&o!=null?o.tileSize[0]:r.blockWidth,h=e&&o!=null?o.tileSize[1]:r.blockHeight,m=pe(t,i,a);if(!s.intersects(m)||n<0||n>c)return null;const p=this.getPyramidPixelSize(n),{x,y:g}=p,d=(l.y-m.y)/g/h,f=(m.x-l.x)/x/u,R=Math.min(h-1,Math.floor((d-Math.floor(d))*h)),w=Math.min(u-1,Math.floor((f-Math.floor(f))*u));return{pyramidLevel:n,row:Math.floor(d),col:Math.floor(f),rowOffset:R,colOffset:w,blockWidth:u,srcLocation:m}}getTileExtent(t,n,a,e,i,s){const[r,c]=s,l=e.x+a*r*t.x,o=l+r*t.x,u=e.y-n*c*t.y,h=u-c*t.y;return new U({xmin:l,xmax:o,ymin:h,ymax:u,spatialReference:i})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,n,a){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<n||e.maxCol<a||e.minRow>n||e.minCol>a}updateImageSpaceRasterInfo(t){const{pixelSize:n}=t,{width:a,height:e}=t,i=be.WebMercator;t.spatialReference=i,t.extent=t.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:a-.5,ymin:.5-e,spatialReference:i}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new P({x:1,y:1,spatialReference:i});const{extent:s,storageInfo:r}=t;if(r){r.origin=new P({x:s.xmin,y:s.ymax,spatialReference:i});const{pyramidResolutions:c,tileInfo:l}=r;if(c&&c.forEach(o=>{o.x/=n.x,o.y/=n.y}),l){l.origin=r.origin;const o=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,h)=>{u.resolution=o*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,n,a,e={}){let i=ne(t);if(i>=2)return{extent:t,pixelBlock:null};const s=this._getSourceDataInfo(t,n,a,e),{pyramidLevel:r,srcResolution:c,srcExtent:l,srcWidth:o,srcHeight:u,ul:h}=s;if(o===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:m}=this,p=m.transform,x=(p==null?void 0:p.type)==="gcs-shift",g=X(t.spatialReference)!=null;!x&&g||(i=ne(s.srcExtent,x));const d=await this._fetchRawTiles(r,h,{width:o,height:u,wrapCount:i},e);if(!d)return{extent:t,srcExtent:l,pixelBlock:null};const f=m.storageInfo,R=r>0?f.pyramidBlockWidth:f.blockWidth,w=r>0?f.pyramidBlockHeight:f.blockHeight;let{x:S,y:T}=m.pixelSize;if(r>0){const{pyramidResolutions:M,pyramidScalingFactor:Fe}=f;if(M!=null&&M[r-1])({x:S,y:T}=M[r-1]);else{const ce=Fe**r;S*=ce,T*=ce}}const $=m.spatialReference,N=new P({x:S,y:T,spatialReference:$}),z=R===o&&w===u&&h.x%R===0&&h.y%w===0,E=new P({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/a,spatialReference:t.spatialReference}),_=!t.spatialReference.equals($),W=$.isGeographic?1e-9:1e-4,{datumTransformation:L}=e;if(!_&&z&&d.pixelBlocks.length===1&&R===n&&w===a&&kt(c,E,W))return{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:d.pixelBlocks[0]};const q=g&&X(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,D=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");D&&!this.rasterJobHandler&&await se();const k=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:E.toJSON(),datumTransformation:L,rasterTransform:p,hasWrapAround:i>0||q,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:D},e):Rt({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:E,datumTransformation:L,rasterTransform:p,hasWrapAround:i>0||q,isAdaptive:!1,includeGCSGrid:D});let F;const B=!e.requestRawData,A={rows:k.spacing[0],cols:k.spacing[1]},H=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,d.extent.xmin):void 0,{pixelBlocks:C,mosaicSize:G,isPartiallyFilled:Q}=d;let j=null;if(this.rasterJobHandler)({pixelBlock:F,localNorthDirections:j}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:G,destDimension:B?{width:n,height:a}:null,coefs:B?k.coefficients:null,sampleSpacing:B?A:null,projectDirections:D,gcsGrid:D?k.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:H,blockWidths:null},e));else{const M=ie(C,G,{alignmentInfo:H});F=B?_e(M,{width:n,height:a},k.coefficients,A,e.interpolation):M,D&&k.gcsGrid&&(j=yt({width:n,height:a},k.gcsGrid),F=xt(F,this.rasterInfo.dataType,j))}return e.requestRawData||D?{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:F,transformGrid:k,localNorthDirections:j,isPartiallyFilled:Q}:{extent:t,srcExtent:l,srcTilePixelSize:N,pixelBlock:F}}async _fetchRawTiles(t,n,a,e){const{origin:i,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:c}=this.getBlockWidthHeight(t);let{x:l,y:o}=n,{width:u,height:h,wrapCount:m}=a;const p=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,o-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let x=0,g=0,d=0;m&&p!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:d,rightPadding:x}=p,g*p.blockWidth-x>=l+u&&(x=0));const f=Math.floor(l/r),R=Math.floor(o/c),w=Math.floor((l+u+x-1)/r),S=Math.floor((o+h+x-1)/c),T=s[t];if(!T)return null;const{minRow:$,minCol:N,maxCol:z,maxRow:E}=T;if(m===0&&(S<$||w<N||R>E||f>z))return null;const _=new Array;let W=!1;const L=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let H=R;H<=S;H++)for(let C=f;C<=w;C++){let G=C;if(!e.disableWrapAround&&m&&p!=null&&g<=C&&(G=C-g-d),H>=$&&G>=N&&E>=H&&z>=G){const Q=this._tileFetchQueue.push({pyramidLevel:t,row:H,col:G,options:e},{signal:e.signal});L?_.push(new Promise(j=>{Q.then(M=>j(M)).catch(()=>{W=!0,j(null)})})):_.push(Q)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const q=await Promise.all(_),D={height:(S-R+1)*c,width:(w-f+1)*r},{spatialReference:k}=this.rasterInfo,F=this.getPyramidPixelSize(t),{x:B,y:A}=F;return{extent:new U({xmin:i.x+f*r*B,xmax:i.x+(w+1)*r*B,ymin:i.y-(S+1)*c*A,ymax:i.y-R*c*A,spatialReference:k}),pixelBlocks:q,mosaicSize:D,isPartiallyFilled:W}}_fetchRawTile(t,n,a,e){const{storageInfo:i}=this.rasterInfo,s=i.transposeInfo!=null&&!!e.transposedVariableName;if(!s){const h=i.blockBoundary[t];if(!h)return Promise.resolve(null);const{minRow:m,minCol:p,maxCol:x,maxRow:g}=h;if(n<m||a<p||n>g||a>x)return Promise.resolve(null)}const r=s?e.transposeVariableName:e.sliceId,c=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,l=ut(this.rasterId,r,c),o=`${t}/${n}/${a}`;let u=ht(l,e.registryId,o);if(u==null){const h=new AbortController;u=this.fetchRawTile(t,n,a,{...e,signal:h.signal}),mt(l,e.registryId,o,u,h),u.catch(()=>ft(l,e.registryId,o))}return e.signal&&Be(e,()=>{dt(l,e.registryId,o)}),u}_computeMagDirValues(t){var l;const{bandCount:n,dataType:a}=this.rasterInfo;if(!(n===2&&a==="vector-magdir"||a==="vector-uv")||(t==null?void 0:t.length)!==2||!((l=t[0])!=null&&l.length))return null;const e=t[0].length;if(a==="vector-magdir"){const o=t[1].map(u=>(u+360)%360);return[t[0],o]}const[i,s]=t,r=[],c=[];for(let o=0;o<e;o++){const[u,h]=gt([i[o],s[o]]);r.push(u),c.push(h)}return[r,c]}_getRasterTileAlignmentInfo(t,n){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=bt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:n,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,n,a,e={}){const i={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(i.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,i));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:c,pyramidLevel:l}=i,o=r/n,u=c/a,h=l<s&&o*u>=16,m=l===s&&this._requireTooManySrcTiles(r,c,n,a);if(h||m||r===0||c===0){const p=new P({x:(t.xmax-t.xmin)/n,y:(t.ymax-t.ymin)/a,spatialReference:t.spatialReference});let x=wt(p,this.rasterInfo.spatialReference,t,i.datumTransformation);const g=!x||e.srcResolution&&x.x+x.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&g){const d=Math.round(Math.log(Math.max(o,u))/Math.LN2)-1;if(s-l+3>=d){const f=2**d;x={x:e.srcResolution.x*f,y:e.srcResolution.y*f}}}x&&(i.srcResolution=x,this._updateSourceDataInfo(t,i))}return this._requireTooManySrcTiles(i.srcWidth,i.srcHeight,n,a)&&(i.srcWidth=0,i.srcHeight=0),i}_requireTooManySrcTiles(t,n,a,e){const{tileInfo:i}=this.rasterInfo.storageInfo,s=Math.ceil(t/i.size[0])*Math.ceil(n/i.size[1]),r=t/a,c=n/e,l=Math.max(1,(a+e)/1024);return s>=_t*l||r>xe||c>xe}_updateSourceDataInfo(t,n){n.srcWidth=0,n.srcHeight=0;const{rasterInfo:a}=this,e=a.spatialReference,{srcResolution:i,datumTransformation:s}=n,{pyramidLevel:r,pyramidResolution:c,excessiveReading:l}=ye(i,a,this.ioConfig.sampling);if(l)return;let o=n.srcExtent||Y(t,e,s);if(o==null)return;const u=a.transform;u&&(o=u.inverseTransform(o)),n.srcExtent=o;const{origin:h}=a.storageInfo,{width:m,height:p,ul:x}=lt(o,h,c,r);n.pyramidLevel=r,n.pyramidResolution=c,n.srcWidth=m,n.srcHeight=p,n.ul=x}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,n){const{srcLocation:a,position:e,pyramidLevel:i,useTransposedTile:s}=n,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:a,value:null};const{multidimensionalInfo:c}=this.rasterInfo;if(c==null||!s){const d=t.pixels.map(w=>w[e]),f={location:a,value:d,pyramidLevel:i},R=this._computeMagDirValues(d.map(w=>[w]));return R!=null&&R.length&&(f.magdirValue=R.map(w=>w[0])),f}let l=t.pixels.map(d=>d.slice(e*r,e*r+r)),o=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:h}=n;let m=Me(c,h.transposedVariableName);if(u){const d=Oe(m,h.multidimensionalDefinition,h.timeExtent);l=l.map(f=>d.map(R=>f[R])),o=o==null?void 0:o.map(f=>d.map(R=>f[R])),m=d.map(f=>m[f])}const p=t.noDataValues||this.rasterInfo.noDataValue,x={pixels:l,pixelType:t.pixelType};let g;return p!=null&&(pt(x,p),g=x.mask),{location:a,value:null,dataSeries:m.map((d,f)=>{const R={value:(g==null?void 0:g[f])===0?null:l.map(w=>w[f]),multidimensionalDefinition:d.multidimensionalDefinition.map(w=>new ve({...w,isSlice:!0}))};return o!=null&&o.length&&(R.magdirValue=[o[0][f],o[1][f]]),R}),pyramidLevel:i}}};function kt(y,t,n){return Math.abs(y.x-t.x)<n&&Math.abs(y.y-t.y)<n}I([b()],v.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],v.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],v.prototype,"_openPromise",void 0),I([b()],v.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],v.prototype,"rasterId",null),I([b(we)],v.prototype,"url",null),I([b({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),I([b()],v.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],v.prototype,"rasterInfo",void 0),I([b()],v.prototype,"ioConfig",void 0),I([b()],v.prototype,"sourceJSON",void 0),v=I([le("esri.layers.support.rasterDatasets.BaseRaster")],v);const Ft=40;let V=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(y,t,n,a={}){var R,w;const{rasters:e,rasterIds:i}=this.primaryRasters;let s=!1;const{interpolation:r}=a,c=(R=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:R.hasFocalFunction;!a.requestRawData&&c&&(s=e.length===1&&!a.skipRasterFunction,a={...a,interpolation:"bilinear",requestRawData:s}),a.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(s=!1,a={...a,requestRawData:!1});const l=e.map(S=>S.fetchPixels(y,t,n,a)),o=await Promise.all(l),u=o.map(S=>S.pixelBlock),h=s||a.requestRawData?o.map(S=>S.srcTilePixelSize):null;if(a.skipRasterFunction||u.every(S=>S==null))return o[0];const m=((w=o.find(S=>S.pixelBlock!=null))==null?void 0:w.extent)??y;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:m,primaryPixelBlocks:u,primaryPixelSizes:h,primaryRasterIds:i}):this.rasterFunction.process({extent:m,primaryPixelBlocks:u,primaryPixelSizes:h,primaryRasterIds:i});const{transformGrid:x}=o[0];if(!s||p==null||x==null){const S=a.noClip?null:this.getClippingGeometry(m.spatialReference);return!a.noClip&&p!=null&&S&&(p=await oe(p,m,S)),{...o[0],pixelBlock:p}}const g={rows:x.spacing[0],cols:x.spacing[1]};let d;this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:t,height:n},coefs:x.coefficients,sampleSpacing:g,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:r,alignmentInfo:void 0,blockWidths:null},a)).pixelBlock:d=_e(p,{width:t,height:n},x.coefficients,g,r);const f=a.noClip?null:this.getClippingGeometry(y.spatialReference);return a.noClip||d==null||f==null||(d=await oe(d,y,f)),{extent:y,srcExtent:o[0].srcExtent,pixelBlock:d}}getClippingGeometry(y){const t=this._clippingGeometry.get("0");if(!y||!t)return t;const n=Dt(y);let a=this._clippingGeometry.get(n);return a!=null||(a=y.equals(t.spatialReference)?t:ae(t,y),this._clippingGeometry.set(n,a)),a}async _open(y){var l,o,u,h;const{rasterFunction:t}=this;t.isRoot=!0,(o=(l=this.primaryRasters)==null?void 0:l.rasters)!=null&&o.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&((u=this.primaryRasters.rasters)==null||u.forEach(m=>m.rasterJobHandler=this.rasterJobHandler)));const{rasters:n,rasterIds:a}=this.primaryRasters,e=n.map(m=>m.rasterInfo?void 0:m.open(y));await Promise.all(e);const i=n.map(({rasterInfo:m})=>m),s=t.bind({rasterInfos:i,rasterIds:a});if(t.rawSourceRasterInfos=i,!s.success||i.length===0)throw new J("raster-function:open",`cannot bind the function: ${s.error??""}`);const r=t.functionName==="Table"?t:(h=t.functionArguments)==null?void 0:h.raster;(r==null?void 0:r.functionName)==="Table"&&(t.rasterInfo.attributeTable=Ce.fromJSON(r.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=i[0];this.hasUniqueSourceStorageInfo=i.length===1||i.slice(1).every(m=>Pt(m,c)),this.set("sourceJSON",n[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var y;return(y=this.rasterJobHandler)==null?void 0:y.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const y=this.rasterFunction.getClippingGeometries()[0];let t=y==null?void 0:y.clippingGeometry;if(t&&y.clippingType==="inside"){const{extent:n}=this.rasterInfo,a=await Z(()=>import("./densifyOperator.js").then(s=>s.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]),import.meta.url),e=await Z(()=>import("./differenceOperator.js").then(s=>s.d),__vite__mapDeps([22,14,15,16,17,1,2,3,4,5,6,7,8,9,10,11,12,13,18,19,21]),import.meta.url);let i=a.execute(ze.fromExtent(n),2*(n.width+n.height)/Ft);i=ae(i,t.spatialReference),t=e.execute(i,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};function Pt(y,t){const{storageInfo:n,pixelSize:a,spatialReference:e,extent:i}=y,{storageInfo:s,pixelSize:r,spatialReference:c,extent:l}=t;return a.x===r.x&&a.y===r.y&&e.equals(c)&&i.equals(l)&&n.blockHeight===s.blockHeight&&n.blockWidth===s.blockWidth&&n.maximumPyramidLevel===s.maximumPyramidLevel&&n.firstPyramidLevel===s.firstPyramidLevel&&n.pyramidBlockWidth===s.pyramidBlockWidth&&n.pyramidBlockHeight===s.pyramidBlockHeight&&n.pyramidScalingFactor===s.pyramidScalingFactor}function Dt(y){return String(y.wkid??y.wkt??y.wkt2)}I([b({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),I([b()],V.prototype,"tileType",void 0),I([b()],V.prototype,"rasterFunction",void 0),I([b()],V.prototype,"primaryRasters",void 0),V=I([le("esri.layers.support.rasterDatasets.FunctionRaster")],V);const ge=1e3,jt=y=>{const t=y;let n=class extends t{constructor(...e){var i;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=O((i=e[0])==null?void 0:i.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var i;((i=e==null?void 0:e.functionName)==null?void 0:i.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Ie(e,re.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:i}=this;if(e){const s=i==null?void 0:i.find(({name:r})=>r===e);return s==null?void 0:s.renderer.clone()}return this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,i,s){var c,l;const r=(l=(c=i==null?void 0:i.layerDefinition)==null?void 0:c.drawingInfo)==null?void 0:l.renderer;return Ue(r,s)||void 0}async computeStatisticsHistograms(e,i){await this.load(i),e=K(Qe,e).clone();const{serviceRasterInfo:s}=this;if(s==null)throw new J("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new J("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let c=r;const{spatialReference:l}=s;if(!r.spatialReference.equals(l)){await se();const d=r.type==="extent"?Y(r,l):ae(r,l);if(d==null)throw new J("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");c=d}const o=e.pixelSize??new P({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:l}),{extent:u,width:h,height:m}=St(s,c,o),p=await this.fetchPixels(u,h,m,{...i,interpolation:"nearest"});if(p.pixelBlock==null)throw new J("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const x=await oe(p.pixelBlock,u,c),g=this._rasterJobHandler;return g?g.computeStatisticsHistograms({pixelBlock:x},i):st(x)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:i}=this.serviceRasterInfo??{};if(i==null)return e;const s=We({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:s,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:i,renderer:s}=this;if(!e||!i||!s)return;const{rasterInfo:r}=this.raster,c=ue(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),l=c==null?void 0:c.name,o=me(r,l);return this._updateSymbolizer(i,s,l,o)}async applyRenderer(e,i,s){const r=e==null?void 0:e.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();const c=this.bandIds??[],{pixelBlock:l}=await this._symbolize({pixelData:e,simpleStretchParams:i,bandIds:c,symbolizer:this.symbolizer},s);return l}getRawDisplayBandIds(){let{bandIds:e,raster:i}=this;if(this.rasterFunction&&O(i)){const s=i.rasterFunction.rawInputBandIds;e=e!=null&&e.length&&(s!=null&&s.length)&&i.rasterInfo.bandCount!==1?e.map(r=>s[Math.min(r,s.length-1)]):s}return e&&e.length>3&&e.every((s,r)=>s===r)?null:e}getTileUrl(e,i,s){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${i}/${s}`:""}getCompatibleTileInfo(e,i,s=!1){if(!this.loaded||i==null)return null;if(s&&e.equals(this.spatialReference))return this.tileInfo;const r=Ne(e);return ee.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:i.xmin,y:i.ymax}})}getCompatibleFullExtent(e){var i;return this.loaded?((i=this._compatibleFullExtent)!=null&&i.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,i,s,r={}){var l;if(a(this),r.requestAsImageElement){const o=this.getTileUrl(e,i,s);return Re(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(u=>u.data)}const{serviceRasterInfo:c}=this;if(c.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const o=r.tileInfo||c.storageInfo.tileInfo,u=this.raster.getTileExtentFromTileInfo(e,i,s,o);if(u)return{extent:u,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((l=this.renderer)==null?void 0:l.type)==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,i,s,r)}async fetchPixels(e,i,s,r={}){var l,o;if(this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),i=Math.round(i),s=Math.round(s);const c=await this.raster.fetchPixels(e,i,s,r);return(l=r.bandIds)!=null&&l.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(c.pixelBlock=(o=c.pixelBlock)==null?void 0:o.extractBands(r.bandIds)),c}async getSamples(e,i){var o;if(await this.load(),(e=K(Xe,e).clone()).interpolation&&e.interpolation!=="nearest")throw new J("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const s=(o=e.mosaicRule)==null?void 0:o.multidimensionalDefinition,r={...i,multidimensionalDefinition:s},c=(await this._getSampleLocations(e)).map(u=>this.identify(u,r).then(h=>(h.location=u,h))),l=(await Promise.all(c)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new Ke({samples:l})}async identify(e,i={}){var o,u;await this.load(),e=K(P,e).clone().normalize();const{raster:s,serviceRasterInfo:r}=this;if((r==null?void 0:r.multidimensionalInfo)!=null&&!(r.hasMultidimensionalTranspose&&!(!Se(i.multidimensionalDefinition)&&!i.transposedVariableName))&&(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition==null)return{location:e,value:null};const c=(o=this.multidimensionalSubset)==null?void 0:o.areaOfInterest;if(c&&!c.contains(e))throw new J("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let l;if((u=this.serviceRasterInfo)!=null&&u.storageInfo.isBsqTile){const h=O(s)?this.getRawDisplayBandIds():this.bandIds;l=h!=null&&h.length?h:void 0}return s.identify(e,{...i,bandIds:l})}hasStandardTime(){var r,c,l;const e=(r=this.serviceRasterInfo)==null?void 0:r.multidimensionalInfo;if(e==null||((c=this.serviceRasterInfo)==null?void 0:c.dataType)!=="standard-time")return!1;const i=this.multidimensionalDefinition,s=(l=i==null?void 0:i[0])==null?void 0:l.variableName;return e.variables.some(o=>o.name===s&&(!(i!=null&&i[0].dimensionName)||o.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Le(e)).toISOString()}getMultidimensionalSubsetVariables(e){var s;const i=e??((s=this.serviceRasterInfo)==null?void 0:s.multidimensionalInfo);return qe(this.multidimensionalSubset,i)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ae(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&O(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;a(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,O(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:i}=e;if(i.type==="point")return[i];const{spatialReference:s,type:r}=i;if(r==="multipoint")return i.points.map(d=>new P({x:d[0],y:d[1],spatialReference:s}));if(r==="polyline"){let d=i;if(e.sampleCount||e.sampleDistance){const f=await Z(()=>import("./densifyOperator.js").then(T=>T.d),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]),import.meta.url),R=(await Z(async()=>{const{execute:T}=await import("./lengthOperator2.js").then($=>$.l);return{execute:T}},__vite__mapDeps([23,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,15,17,18,19,21]),import.meta.url)).execute(i,{unit:"meters"}),w=Math.min(e.sampleCount||100,ge);let S=e.sampleDistance;S||(S=R/(w+(d.paths[0].length===2?1:0))),d=f.execute(i,S,{unit:"meters"})}return d.paths.flatMap(f=>f.map(R=>new P({x:R[0],y:R[1],spatialReference:s})))}const c=Math.min(e.sampleCount||100,ge),l=i.type==="extent",o=l?i:i.extent,u=Math.sqrt(o.width*o.height/c),h=o.height/u,m=o.width/u,{xmin:p,ymax:x}=o,g=[];for(let d=0;d<h;d++)for(let f=0;f<m;f++){const R=new P({x:p+(f+.5)*u,y:x-(d+.5)*u,spatialReference:s});(l||i.contains(R))&&g.push(R)}return g}_configDefaultInterpolation(){var e;if(this.interpolation==null){a(this);const{raster:i}=this,s=Ye(i.rasterInfo,i.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(e="no"){var h,m,p;a(this);const{rasterInfo:i}=this.raster,s=ue(i,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=s==null?void 0:s.name,c=Ze({variableName:r,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&i.bandCount>1&&(this.bandIds=(c==null?void 0:c.bandIds)??et(i)),!this.renderer||e==="override"){const x=tt(this.raster),g=(c==null?void 0:c.renderer)??fe(i,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:x}),d=i.statistics,f=d&&d.length>0?d[0]:null,R=(f==null?void 0:f.max)??0,w=(f==null?void 0:f.min)??0;this.raster.datasetFormat==="WCSServer"&&g.type==="raster-stretch"&&(R>1e24||w<-1e24)&&(g.dynamicRangeAdjustment=!0,g.customStatistics=null,g.stretchType==="none"&&(g.stretchType="min-max")),this.renderer=g}const l=it({...this.renderer.toJSON(),variableName:r}),o=me(i,r);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=o):this.symbolizer=new at({rendererJSON:l,rasterInfo:o});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:x}=this.raster.rasterInfo,g=this.renderer;if(x!=null&&g.type==="raster-colormap"){const d=fe(this.raster.rasterInfo);JSON.stringify(d)!==JSON.stringify(g)&&this._configDefaultRenderer("override")}else if(g.type==="raster-stretch"){const d=(m=this.bandIds)==null?void 0:m.length,f=(p=g.customStatistics)==null?void 0:p.length;!g.dynamicRangeAdjustment&&f&&d&&f!==d&&this._configDefaultRenderer("override")}}}else re.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&O(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",he.fromJSON(h)))}let e,i=this.raster,s=!1;O(i)?(e=i.primaryRasters.rasters,i=e[0],s=!0):e=[i];const{rasterFunction:r}=this;if(r){const h={raster:i};e.length>1&&e.forEach(x=>h[x.url]=x);const m=vt(((u=r.functionDefinition)==null?void 0:u.toJSON())??r.toJSON(),h),p=new V({rasterFunction:m});p.rasterJobHandler=this._rasterJobHandler,await p.open(),this.raster=p}else this.raster=i,await i.open();if(this._cachedRendererJson=void 0,!s&&!r)return;const{bandIds:c}=this,{bandCount:l}=this.raster.rasterInfo,o=c!=null&&c.length?c.some(h=>h>=l):l>=3;c&&(o||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,i){var o;const{rasterInfo:s}=this.raster,r=s.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),c=(s.pixelSize.x+s.pixelSize.y)/2*r;if(!((o=e.dataSeries)!=null&&o.length))return[new de({location:e.location,pixelValue:e.value,locationId:i,resolution:c})];const l=[];return e.dataSeries.forEach(({value:u,multidimensionalDefinition:h},m)=>{const p={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:g})=>g).join(",")};for(const{dimensionName:g,values:d}of h){p[g]=Array.isArray(d[0])?d[0][0]:d[0];const f=d[d.length-1];p[`${g}_Max`]=Array.isArray(f)?f[f.length-1]:f}const x=new de({location:e.location,pixelValue:u,rasterId:m,locationId:i,resolution:c,attributes:p});l.push(x)}),l}};function a(e){if(!e.raster||!e.serviceRasterInfo)throw new J("imagery-tile","no raster")}return I([b({clonable:!1})],n.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],n.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],n.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],n.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[He],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],n.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],n.prototype,"copyright",void 0),I([b({json:{read:!1}})],n.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),$e(ot)],n.prototype,"interpolation",void 0),I([b()],n.prototype,"ioConfig",void 0),I([b({type:[ve],json:{write:!0}})],n.prototype,"multidimensionalDefinition",null),I([b({type:Ge,json:{write:!0}})],n.prototype,"multidimensionalSubset",void 0),I([b()],n.prototype,"raster",void 0),I([b({type:he})],n.prototype,"rasterFunction",null),I([b()],n.prototype,"serviceRasterInfo",void 0),I([b()],n.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:be,json:{read:!1}})],n.prototype,"spatialReference",void 0),I([b({type:ee})],n.prototype,"tileInfo",void 0),I([b(we)],n.prototype,"url",null),I([b()],n.prototype,"renderer",null),I([b({types:Ve,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var i;const e=((i=this.renderer)==null?void 0:i.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:je,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],n.prototype,"internalRenderer",null),I([Je("internalRenderer")],n.prototype,"readRenderer",null),I([b({clonable:!1})],n.prototype,"symbolizer",void 0),n=I([le("esri.layers.mixins.ImageryTileMixin")],n),n};function te(y,t){if(!y||!t)return[];let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const a=[];if(t){const i=te(y,n);for(let s=0;s<i.length;s++)te(i[s],t).forEach(r=>a.push(r));return a}const e=y.getElementsByTagNameNS("*",n);if(!e||e.length===0)return[];for(let i=0;i<e.length;i++)a.push(e[i]||e.item(i));return a}function Te(y,t){if(!y||!t)return null;let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const a=te(y,n);return a.length>0?t?Te(a[0],t):a[0]:null}function ke(y,t=null){const n=t?Te(y,t):y;let a;return n?(a=n.textContent||n.nodeValue,a?a.trim():null):null}function Bt(y,t){const n=te(y,t),a=[];let e;for(let i=0;i<n.length;i++)e=n[i].textContent||n[i].nodeValue,e&&(e=e.trim(),e!==""&&a.push(e));return a}function Vt(y,t=null){const n=ke(y,t);return(n==null?void 0:n.split(" ").map(a=>Number(a)))??[]}function Ut(y,t){return Bt(y,t).map(n=>Number(n))}function Qt(y,t){const n=ke(y,t);return Number(n)}function Xt(y,t){var e;const n=(e=y==null?void 0:y.nodeName)==null?void 0:e.toLowerCase(),a=t.toLowerCase();return n.slice(n.lastIndexOf(":")+1)===a}function Kt(y){return y.nodeName.slice(y.nodeName.lastIndexOf(":")+1)}export{v as X,jt as a,Kt as c,Te as e,Xt as i,Bt as l,V as m,te as n,Qt as o,Vt as r,ke as t,Ut as u};
