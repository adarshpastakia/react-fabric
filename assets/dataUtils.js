import{dF as N,l as nt,ar as ot,fo as Q,fp as H,a4 as rt,b0 as it,eU as lt}from"./ShadowCastClear.glsl.js";const T=()=>nt.getLogger("esri.views.2d.engine.flow.dataUtils"),at=10;async function gt(m,t,o,u){const d=performance.now(),g=st(t,o),c=performance.now(),r=ft(t,g,o.width,o.height),e=performance.now(),n=ut(r),i=performance.now(),M=m==="Streamlines"?dt(n,at):wt(n),A=performance.now();return N("esri-2d-profiler")&&(T().info("I.1","_createFlowFieldFromData (ms)",Math.round(c-d)),T().info("I.2","_getStreamlines (ms)",Math.round(e-c)),T().info("I.3","createAnimatedLinesData (ms)",Math.round(i-e)),T().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(A-i)),T().info("I.5","createFlowMesh (ms)",Math.round(A-d)),T().info("I.6","Mesh size (bytes)",M.vertexData.buffer.byteLength+M.indexData.buffer.byteLength)),await Promise.resolve(),ot(u),M}function st(m,t){const o=ht(t.data,t.width,t.height,m.smoothing);return m.interpolate?(u,d)=>{const g=Math.floor(u),c=Math.floor(d);if(g<0||g>=t.width)return[0,0];if(c<0||c>=t.height)return[0,0];const r=u-g,e=d-c,n=g,i=c,M=g<t.width-1?g+1:g,A=c<t.height-1?c+1:c,l=o[2*(i*t.width+n)],f=o[2*(i*t.width+M)],x=o[2*(A*t.width+n)],v=o[2*(A*t.width+M)],y=o[2*(i*t.width+n)+1],h=o[2*(i*t.width+M)+1];return[(l*(1-e)+x*e)*(1-r)+(f*(1-e)+v*e)*r,(y*(1-e)+o[2*(A*t.width+n)+1]*e)*(1-r)+(h*(1-e)+o[2*(A*t.width+M)+1]*e)*r]}:(u,d)=>{const g=Math.round(u),c=Math.round(d);return g<0||g>=t.width||c<0||c>=t.height?[0,0]:[o[2*(c*t.width+g)],o[2*(c*t.width+g)+1]]}}function W(m,t,o,u,d,g,c,r){const e=[],{raster:n,width:i,height:M,resolutionFactor:A}=r;let l=u,f=d,x=0,[v,y]=o(l,f);v*=t.velocityScale,y*=t.velocityScale;const h=Math.sqrt(v*v+y*y);let p,w;e.push({x:l,y:f,t:x,speed:h});for(let a=0;a<t.verticesPerLine;a++){let[s,D]=o(l,f);s*=t.velocityScale,D*=t.velocityScale;const F=Math.sqrt(s*s+D*D);if(F<t.minSpeedThreshold)return e;const L=m*s/F,_=m*D/F;if(l+=L*t.segmentLength,f+=_*t.segmentLength,t.wrapAround&&(l=H(l,g[0])),x+=m*t.segmentLength/F,Math.acos(L*p+_*w)>t.maxTurnAngle)return e;if(t.collisions){let P=Math.round(l*A);const S=Math.round(f*A);if(t.wrapAround&&(P=H(P,i)),P<0||P>i-1||S<0||S>M-1)return e;const B=n[S*i+P];if(B!==-1&&B!==c)return e;n[S*i+P]=c}e.push({x:l,y:f,t:x,speed:F}),p=L,w=_}return e}function ct(m,t,o,u,d,g,c,r){const e=Math.round((.2+.6*c.getFloat())*m.verticesPerLine),n=m.verticesPerLine-e,i=W(-1,{...m,verticesPerLine:n},t,o,u,d,g,r),M=W(1,{...m,verticesPerLine:e},t,o,u,d,g,r),A=i.reverse();return A.splice(-1,1),A.concat(M)}function ft(m,t,o,u,d={positions:[]}){if(m.density<=0)return[];const{positions:g}=d,c=[],r=new Q,e=1/Math.max(m.lineCollisionWidth,1),n=Math.round(o*e),i=Math.round(u*e),M=new Int32Array(n*i);for(let h=0;h<M.length;h++)M[h]=-1;const A={raster:M,width:n,height:i,resolutionFactor:e},l={},f=m.lineSpacing/Math.sqrt(m.density),x=Math.floor(u/f),v=Math.floor(o/f);for(let h=0;h<x;h++){const p=h*f;for(let w=0;w<v;w++){const a=w*f;l[`${w}-${h}`]={x:a,y:p,positions:[]}}}for(const{x:h,y:p}of g){const w=l[`${Math.floor(h/f)}-${Math.floor(p/f)}`];w&&w.positions.push([h,p])}const y=[];for(const h in l){const p=l[h];if(p.positions.length===0)y.push({x:p.x+f/2,y:p.y+f/2,sort:.66+.33*r.getFloat(),stage:0});else{const[w]=p.positions.splice(0,1);y.push({x:w[0],y:w[1],sort:.33*r.getFloat(),stage:1});for(const[a,s]of p.positions)y.push({x:a,y:s,sort:.33+.33*r.getFloat(),stage:2})}}y.sort((h,p)=>h.sort-p.sort);for(const{x:h,y:p,stage:w}of y){const a=m.onlyForwardTracing?W(1,m,t,h,p,[o,u],c.length,A):ct(m,t,h,p,[o,u],c.length,r,A);a.length<2||c.push({stage:w,vertices:a})}return c}function ht(m,t,o,u){if(u===0)return m;const d=Math.round(3*u),g=new Array(2*d+1);let c=0;for(let n=-d;n<=d;n++){const i=Math.exp(-n*n/(u*u));g[n+d]=i,c+=i}for(let n=-d;n<=d;n++)g[n+d]/=c;const r=new Float32Array(m.length);for(let n=0;n<o;n++)for(let i=0;i<t;i++){let M=0,A=0;for(let l=-d;l<=d;l++){if(i+l<0||i+l>=t)continue;const f=g[l+d];M+=f*m[2*(n*t+(i+l))],A+=f*m[2*(n*t+(i+l))+1]}r[2*(n*t+i)]=M,r[2*(n*t+i)+1]=A}const e=new Float32Array(m.length);for(let n=0;n<t;n++)for(let i=0;i<o;i++){let M=0,A=0;for(let l=-d;l<=d;l++){if(i+l<0||i+l>=o)continue;const f=g[l+d];M+=f*r[2*((i+l)*t+n)],A+=f*r[2*((i+l)*t+n)+1]}e[2*(i*t+n)]=M,e[2*(i*t+n)+1]=A}return e}function ut(m,t){const o=new Q,u=m.reduce((e,n)=>e+n.vertices.length,0),d=new Float32Array(4*u),g=new Array(m.length);let c=0,r=0;for(const{vertices:e}of m){const n=c;for(const i of e)d[4*c]=i.x,d[4*c+1]=i.y,d[4*c+2]=i.t,d[4*c+3]=i.speed,c++;g[r++]={startVertex:n,numberOfVertices:e.length,totalTime:e[e.length-1].t,timeSeed:o.getFloat()}}return{lineVertices:d,lineDescriptors:g}}function dt(m,t){const{lineVertices:u,lineDescriptors:d}=m;let g=0,c=0;for(const l of d)g+=2*l.numberOfVertices,c+=6*(l.numberOfVertices-1);const r=new Float32Array(g*9),e=new Uint32Array(c);let n=0,i=0;function M(){e[i++]=n-2,e[i++]=n,e[i++]=n-1,e[i++]=n,e[i++]=n+1,e[i++]=n-1}function A(l,f,x,v,y,h,p,w){const a=n*9;let s=0;r[a+s++]=l,r[a+s++]=f,r[a+s++]=1,r[a+s++]=x,r[a+s++]=h,r[a+s++]=p,r[a+s++]=v/2,r[a+s++]=y/2,r[a+s++]=w,n++,r[a+s++]=l,r[a+s++]=f,r[a+s++]=-1,r[a+s++]=x,r[a+s++]=h,r[a+s++]=p,r[a+s++]=-v/2,r[a+s++]=-y/2,r[a+s++]=w,n++}for(const l of d){const{totalTime:f,timeSeed:x}=l;let v=null,y=null,h=null,p=null,w=null,a=null;for(let s=0;s<l.numberOfVertices;s++){const D=u[4*(l.startVertex+s)],F=u[4*(l.startVertex+s)+1],L=u[4*(l.startVertex+s)+2],_=u[4*(l.startVertex+s)+3];let P=null,S=null,B=null,j=null;if(s>0){P=D-v,S=F-y;const V=Math.sqrt(P*P+S*S);if(P/=V,S/=V,s>1){let I=P+w,b=S+a;const k=Math.sqrt(I*I+b*b);I/=k,b/=k;const R=Math.min(1/(I*P+b*S),t);I*=R,b*=R,B=-b,j=I}else B=-S,j=P;B!==null&&j!==null&&(A(v,y,h,B,j,f,x,_),M())}v=D,y=F,h=L,w=P,a=S,p=_}A(v,y,h,-a,w,f,x,p)}return{vertexData:r,indexData:e}}function wt(m){const{lineVertices:d,lineDescriptors:g}=m;let c=0,r=0;for(const V of g){const I=V.numberOfVertices-1;c+=4*I*2,r+=6*I*2}const e=new Float32Array(c*16),n=new Uint32Array(r);let i,M,A,l,f,x,v,y,h,p,w,a,s,D,F=0,L=0;function _(){n[L++]=F-8,n[L++]=F-7,n[L++]=F-6,n[L++]=F-7,n[L++]=F-5,n[L++]=F-6,n[L++]=F-4,n[L++]=F-3,n[L++]=F-2,n[L++]=F-3,n[L++]=F-1,n[L++]=F-2}function P(V,I,b,k,R,C,O,z,E,G,X,Y,Z,$){const q=F*16;let U=0;for(const tt of[1,2])for(const et of[1,2,3,4])e[q+U++]=V,e[q+U++]=I,e[q+U++]=b,e[q+U++]=k,e[q+U++]=O,e[q+U++]=z,e[q+U++]=E,e[q+U++]=G,e[q+U++]=tt,e[q+U++]=et,e[q+U++]=Z,e[q+U++]=$,e[q+U++]=R/2,e[q+U++]=C/2,e[q+U++]=X/2,e[q+U++]=Y/2,F++}function S(V,I){let b=h+w,k=p+a;const R=Math.sqrt(b*b+k*k);b/=R,k/=R;const C=h*b+p*k;b/=C,k/=C;let O=w+s,z=a+D;const E=Math.sqrt(O*O+z*z);O/=E,z/=E;const G=w*O+a*z;O/=G,z/=G,P(i,M,A,l,-k,b,f,x,v,y,-z,O,V,I),_()}function B(V,I,b,k,R,C){if(h=w,p=a,w=s,a=D,h==null&&p==null&&(h=w,p=a),f!=null&&x!=null){s=V-f,D=I-x;const O=Math.sqrt(s*s+D*D);s/=O,D/=O}h!=null&&p!=null&&S(R,C),i=f,M=x,A=v,l=y,f=V,x=I,v=b,y=k}function j(V,I){h=w,p=a,w=s,a=D,h==null&&p==null&&(h=w,p=a),h!=null&&p!=null&&S(V,I)}for(const V of g){i=null,M=null,A=null,l=null,f=null,x=null,v=null,y=null,h=null,p=null,w=null,a=null,s=null,D=null;const{totalTime:I,timeSeed:b}=V;for(let k=0;k<V.numberOfVertices;k++)B(d[4*(V.startVertex+k)],d[4*(V.startVertex+k)+1],d[4*(V.startVertex+k)+2],d[4*(V.startVertex+k)+3],I,b);j(I,b)}return{vertexData:e,indexData:n}}function J(m,t,o=t.width,u=t.height,d=0,g=0){const c=t.pixels,r=o*u,e=2,n=new Float32Array(r*e),i=t.width,M=(f,x)=>f+d+(x+g)*i,A=(f,x)=>f+x*o;let l;if(t.mask!=null)if(o!==t.width||u!==t.height||d!==0||g!==0){l=new Uint8Array(r*e);const f=t.mask;for(let x=0;x<u;++x)for(let v=0;v<o;++v){const y=M(v,x),h=A(v,x);l[e*h]=f[e*y],l[e*h+1]=f[e*y+1]}}else l=t.mask;else l=new Uint8Array(r*e),l.fill(255);if(m==="vector-uv")for(let f=0;f<u;++f)for(let x=0;x<o;++x){const v=M(x,f),y=A(x,f);n[e*y]=c[0][v],n[e*y+1]=-c[1][v]}else if(m==="vector-magdir"){const{cos:f,sin:x}=Math;for(let v=0;v<u;++v)for(let y=0;y<o;++y){const h=M(y,v),p=A(y,v),w=c[0][h],a=lt(c[1][h]),s=f(a-Math.PI/2),D=x(a-Math.PI/2);n[e*p]=s*w,n[e*p+1]=D*w}}return{data:n,mask:l,width:o,height:u}}async function pt(m,t,o,u,d,g){const c=performance.now(),r=rt(t.spatialReference);if(!r){const w=await K(m,t,o,u,d,g);return N("esri-2d-profiler")&&T().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-c)),N("esri-2d-profiler")&&T().info("I.9","Number of parts",1),w}const[e,n]=r.valid,i=n-e,M=Math.ceil(t.width/i),A=t.width/M,l=Math.round(o/M);let f=t.xmin;const x=[],v=performance.now();for(let w=0;w<M;w++){const a=new it({xmin:f,xmax:f+A,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});x.push(K(m,a,l,u,d,g)),f+=A}const y=await Promise.all(x);if(N("esri-2d-profiler")&&T().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-v)),N("esri-2d-profiler")&&T().info("I.9","Number of parts",y.length),y.length===1)return N("esri-2d-profiler")&&T().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-c)),y[0];const h={data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u};let p=0;for(const w of y){for(let a=0;a<w.height;a++)for(let s=0;s<w.width;s++)p+s>=o||(h.data[2*(a*o+p+s)]=w.data[2*(a*w.width+s)],h.data[2*(a*o+p+s)+1]=w.data[2*(a*w.width+s)+1],h.mask[a*o+p+s]=w.mask[a*w.width+s]);p+=w.width}return N("esri-2d-profiler")&&T().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-c)),h}async function K(m,t,o,u,d,g){var e;const c={requestProjectedLocalDirections:!0,signal:g};if(d!=null&&(c.timeExtent=d),m.type==="imagery"){await m.load({signal:g});const n=await m.internalFetchImage(t,o,u,c);return((e=n==null?void 0:n.pixelData)==null?void 0:e.pixelBlock)==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:J(m.rasterInfo.dataType,n.pixelData.pixelBlock)}await m.load({signal:g});const r=await m.fetchPixels(t,o,u,c);return(r==null?void 0:r.pixelBlock)==null?{data:new Float32Array(o*u*2),mask:new Uint8Array(o*u),width:o,height:u}:J(m.serviceRasterInfo.dataType,r.pixelBlock)}export{gt as c,ft as d,st as f,pt as x,J as y};
