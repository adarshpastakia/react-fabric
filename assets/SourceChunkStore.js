import{sa as S,zg as we,zh as Te,iN as x,s1 as W,zi as Me,uE as R,uV as N,fq as ke,jO as We,cf as se,uN as Se,b2 as Fe,hF as Ce,K as v,s5 as re,fa as V,eS as H,zj as $e,zk as X,uY as Z,uZ as J,iH as je,lP as Oe,bD as Ge,dF as Y}from"./ShadowCastClear.glsl.js";import{r as Ae}from"./parquet.js";import{a as ze,O as ie,u as Ee,r as De}from"./FeatureStoreQueryAdapter.js";import{a as j}from"./queryUtils.js";let ne=class{constructor(e){this._statistics=e}get statistics(){return this._statistics}};const K=Math.PI/180;let B=class U{static create(e){return new U(e.map(t=>Pe(t)))}constructor(e){this._statistics=e}static get estimatedMemory(){return S+4*S}values(){return this._statistics.values()}insert(e,t){for(const s of this._statistics)s.insert(e,t)}merge(e){for(let t=0;t<this._statistics.length;t++){const s=this._statistics[t],r=e._statistics[t];if(s.field.name!==r.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");s.merge(r)}}clone(){return new U(this._statistics.map(e=>e.clone()))}};function Pe(u){switch(u.statisticType){case"min":return new q(u);case"max":return new Xe(u);case"avg":return new Be(u);case"avg_angle":return new Ue(u);case"sum":case"count":return new Ye(u);case"mode":return new Le(u)}}let T=class{constructor(e){this.field=e}insert(e,t){if(!this.field.computed)return;const s=this.field.computed.read(e,t);ze(s)||this._insertValue(s)}};class q extends T{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(e){this.value=Math.min(this.value,e)}merge(e){this.value=Math.min(this.value,e.value)}clone(){const e=new q(this.field);return e.value=this.value,e}}let Xe=class oe extends T{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(e){this.value=Math.max(this.value,e)}merge(e){this.value=Math.max(this.value,e.value)}clone(){const e=new oe(this.field);return e.value=this.value,e}},Ye=class ae extends T{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(e){this.value+=e}merge(e){this.value+=e.value}clone(){const e=new ae(this.field);return e.value=this.value,e}},Be=class he extends T{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(e){this._total+=e,this._count+=1}merge(e){this._total+=e._total,this._count+=e._count}clone(){const e=new he(this.field);return e._total=this._total,e._count=this._count,e}},Ue=class de extends T{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const e=this._x/this._count,t=this._y/this._count,s=180/Math.PI;return Math.atan2(t,e)*s}_insertValue(e){this._x=this._x+Math.cos(e*K),this._y=this._y+Math.sin(e*K),this._count+=1}merge(e){this._x+=e._x,this._y+=e._y,this._count+=e._count}clone(){const e=new de(this.field);return e._x=this._x,e._y=this._y,e._count=this._count,e}},Le=class le extends T{constructor(){super(...arguments),this._frequencies=new Map}get value(){let e,t=0;for(const[s,r]of this._frequencies.entries())r>t&&(t=r,e=s);return e}_insertValue(e){const t=this._frequencies.get(e);t!=null?this._frequencies.set(e,t+1):this._frequencies.set(e,1)}merge(e){for(const[t,s]of e._frequencies.entries()){const r=this._frequencies.get(t);r!=null?this._frequencies.set(t,r+s):this._frequencies.set(t,s)}}clone(){const e=new le(this.field);return e._frequencies=new Map(this._frequencies),e}};class b extends ne{static createId(e,t){return`${e}.${t}`}static create(e,t,s,r){return new b(e,t,B.create(s),r)}constructor(e,t,s,r){super(s),this.gridX=e,this.gridY=t,this._worldUnitsPerCell=r,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return b.createId(this.gridX,this.gridY)}get containedObjectIds(){return this._objectIds}get count(){return this._count}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}get usedMemory(){return 48}clone(){const e=new b(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._firstFeatureAttributes=this._firstFeatureAttributes,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r){this._count===0?this._firstFeatureAttributes=e.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=s,this._yWorldTotal+=r,this._statistics.insert(e,t),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._firstFeatureAttributes=e._firstFeatureAttributes,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroidX(e){return e==null?this.centroidXWorld:we(e,this.centroidXWorld)}getCentroidY(e){return e==null?this.centroidYWorld:Te(e,this.centroidYWorld)}getGeometry(e,t){const s=this.gridX*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell,i=new x([4],[s,r,s+this._worldUnitsPerCell,r,s+this._worldUnitsPerCell,r+this._worldUnitsPerCell,s,r+this._worldUnitsPerCell]);if(t!=null){const n=new x;return W(n,i,!1,!1,"esriGeometryPolygon",t)}return i}getCentroid(e){const t=new x([],[this.centroidXWorld,this.centroidYWorld]);if(e!=null){const s=new x;return W(s,t,!1,!1,"esriGeometryPoint",e)}return t}getGeometricCentroid(e,t){const s=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,i=new x([],[s,r]);if(t!=null){const n=new x;return W(n,i,!1,!1,"esriGeometryPoint",t)}return i}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return this._firstFeatureAttributes!=null?{...e,...this._firstFeatureAttributes}:e}}let ue=class{constructor(e){this._options=e}insert(e,t){const s=e.getCursor(),{arcadeContextInfo:r,scale:i}=this._options,n=Me(i,r);for(;s.next();)this._insertFeature(s,n,this._options.sqlOptions,t)}_insertFeature(e,t,s,r){const{featureFilter:i}=this._options;if(i!==null&&!i.check(e,s))return;let n=0,d=0;if(e.geometryType==="esriGeometryPoint")n=e.readXWorldSpace(),d=e.readYWorldSpace();else{if(r){const o=e.readCentroidForDisplay();if(o==null)return;const[a,c]=o.coords;if(a<0||a>R||c<0||c>R)return}const h=e.readCentroidWorldSpace();if(h==null)return;n=h.coords[0],d=h.coords[1]}this._insert(e,n,d,t)}};const Ne=96;function qe(u,e){return ke(u)*We*Ne/e}let Re=class extends ue{constructor(e){super(e),this._cells=new Map,this._pixelsPerMapUnit=qe(e.spatialReference,e.scale)}get usedMemory(){const e=this._cells.values().next().value;return e?(N+e.usedMemory)*this._cells.size:0}put(e){for(const t of this._cells.values()){const s=e.get(t.id);s?s.merge(t):e.set(t.id,t.clone())}}putBounded(e,t,s){const r=[t.xmin,t.ymin,t.xmax,t.ymax],[i,n,d,h]=r,o=Math.floor(i*this._pixelsPerMapUnit/this._options.cellSize),a=Math.floor(n*this._pixelsPerMapUnit/this._options.cellSize),c=Math.ceil(d*this._pixelsPerMapUnit/this._options.cellSize),f=Math.ceil(h*this._pixelsPerMapUnit/this._options.cellSize);for(let _=a;_<=f;_++)for(let l=o;l<=c;l++){const m=`${l}.${_}`,p=this._cells.get(m);if(!p)continue;const g=e.get(p.id);g?p&&!e.has(p.id)&&g.merge(p):e.set(p.id,p.clone())}}_insert(e,t,s,r){const i=t*this._pixelsPerMapUnit,n=s*this._pixelsPerMapUnit,d=Math.floor(i/this._options.cellSize),h=Math.floor(n/this._options.cellSize);this._getCellOrCreate(d,h).insert(e,r,t,s)}_getCellOrCreate(e,t){const s=b.createId(e,t);let r=this._cells.get(s);if(!r){const i=1*this._options.cellSize/this._pixelsPerMapUnit;r=b.create(e,t,this._options.fields,i),this._cells.set(s,r)}return r}},Ve=class ce{static fromReader(e){const t=[],s=e.copy(),r=se();for(;s.next();)s.getBounds(r)&&t.push(s.getIndex());const i=Se(9,n=>(s.setIndex(n),{minX:s.getBoundsXMin(),minY:s.getBoundsYMin(),maxX:s.getBoundsXMax(),maxY:s.getBoundsYMax()}));return i.load(t),new ce(i,t.length)}constructor(e,t){this._index=e,this._size=t}get usedMemory(){return this._size*N}search(e){const t={minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]};return this._index.search(t)}};const He=64;function Ze(u,e,t,s){const r=[u.xmin,u.ymin,u.xmax,u.ymax],i=Fe.fromExtent(Ce(r,s)),n=j(i,s,v.WGS84,{extendedParams:{densificationStep:e*He}});if(!n)return null;const d=re(new x,n,!1,!1),h=d.coords.filter((p,g)=>!(g%2)),o=d.coords.filter((p,g)=>g%2),a=Math.min(...h),c=Math.min(...o),f=Math.max(...h),_=Math.max(...o),l=L(a,c,t,v.WGS84),m=L(f,_,t,v.WGS84);return l&&m?{bounds:r,geohashBounds:{xLL:l[0],yLL:l[1],xTR:m[0],yTR:m[1]},level:t}:null}function L(u,e,t,s){if(s.isWebMercator){const n=V(u/H.radius),d=n-360*Math.floor((n+180)/360),h=[0,0];return Q(h,0,V(Math.PI/2-2*Math.atan(Math.exp(-e/H.radius))),d,t),h}const r=j({x:u,y:e},s,v.WGS84);if(!r)return null;const i=[0,0];return Q(i,0,r.y,r.x,t),i}function Je(u,e){let t=-90,s=90,r=-180,i=180;for(let n=0;n<e;n++){const d=Math.ceil((n+1)/2),h=Math.floor((n+1)/2),o=1-n%2,a=30-(3*d+2*h),c=30-(2*d+3*h),f=3*o+2*(1-o),_=2*o+3*(1-o),l=3*o+7*(1-o)<<c,m=(7*o+3*(1-o)<<a&u.geohashX)>>a,p=(l&u.geohashY)>>c;for(let g=f-1;g>=0;g--){const I=(r+i)/2,y=m&1<<g?1:0;r=(1-y)*r+y*I,i=(1-y)*I+y*i}for(let g=_-1;g>=0;g--){const I=(t+s)/2,y=p&1<<g?1:0;t=(1-y)*t+y*I,s=(1-y)*I+y*s}}return[r,t,i,s]}function Q(u,e,t,s,r){r%2&&(r+=1);let i=0,n=0,d=-90,h=90,o=-180,a=180;for(let c=0;c<r/2;c++){for(let f=0;f<5;f++){const _=(o+a)/2,l=s>_?1:0;i|=l<<29-(f+5*c),o=(1-l)*o+l*_,a=(1-l)*_+l*a}for(let f=0;f<5;f++){const _=(d+h)/2,l=t>_?1:0;n|=l<<29-(f+5*c),d=(1-l)*d+l*_,h=(1-l)*_+l*h}}u[2*e]=i,u[2*e+1]=n}const ee=32;class w extends ne{static create(e,t,s,r){const i=B.create(e),n=new Array(ee);for(let d=0;d<n.length;d++)n[d]=null;return new w(i,t,s,r,n)}constructor(e,t,s,r,i){super(e),this.xNode=t,this.yNode=s,this.depth=r,this.children=i,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}static get estimatedMemory(){let e=0;return e+=2*S,e+=N*ee,e+=B.estimatedMemory,e}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const e=new w(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._xGeohashTotal=this._xGeohashTotal,e._yGeohashTotal=this._yGeohashTotal,e.next=this.next,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r,i,n){this._count+=1,this._xWorldTotal+=t,this._yWorldTotal+=s,this._xGeohashTotal+=r,this._yGeohashTotal+=i,this._statistics.insert(e,n),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._xGeohashTotal+=e._xWorldTotal,this._yGeohashTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroid(e){throw new Error("getCentroid not supported for GeohashNode")}getGeometry(e,t){const s=this._getLngLatBounds(),[r,i,n,d]=s,h=j({rings:[[[r,i],[r,d],[n,d],[n,i],[r,i]]]},v.WGS84,e),o=re(new x,h,!1,!1);return t!=null?W(new x,o,!1,!1,"esriGeometryPolygon",t,!1,!1):o}getGeometricCentroid(e,t){const s=this._getLngLatBounds(),[r,i,n,d]=s,h=j({x:(r+n)/2,y:(i+d)/2},v.WGS84,e),o=$e(new x,h);return t!=null?W(new x,o,!1,!1,"esriGeometryPoint",t,!1,!1):o}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return e.aggregateCount=this._count,e}find(e,t,s,r,i,n){if(r>=s)return this;const d=1-r%2,h=3*d+2*(1-d),o=2*d+3*(1-d),a=30-i-h,c=30-n-o,f=((e&7*d+3*(1-d)<<a)>>a)+((t&3*d+7*(1-d)<<c)>>c)*(8*d+4*(1-d)),_=this.children[f];return _==null?null:_.find(e,t,s,r+1,i+h,n+o)}_getLngLatBounds(){const e=this.depth,t=Math.ceil(e/2),s=Math.floor(e/2),r=30-(3*t+2*s),i=30-(2*t+3*s),n=this.xNode<<r,d=this.yNode<<i;return Je({geohashX:n,geohashY:d},this.depth)}}class Ke{constructor(e){this._fields=e,this._size=0,this._depth=0,this._root=w.create(this._fields,0,0,0)}destroy(){}get size(){return this._size}get depth(){return this._depth}get usedMemory(){return this._size*w.estimatedMemory}find(e,t,s){return this._root.find(e,t,s,0,0,0)}insert(e,t,s,r,i,n,d){let h=this._root,o=0,a=0,c=0;for(;h!==null;){if(h.insert(e,t,s,r,i,d),o>=n)return;const f=Math.ceil((o+1)/2),_=Math.floor((o+1)/2),l=1-o%2,m=30-(3*f+2*_),p=30-(2*f+3*_),g=(r&7*l+3*(1-l)<<m)>>m,I=(i&3*l+7*(1-l)<<p)>>p,y=g+I*(8*l+4*(1-l));a=a<<3*l+2*(1-l)|g,c=c<<2*l+3*(1-l)|I,h.children[y]==null&&(h.children[y]=w.create(this._fields,a,c,o+1),this._depth=Math.max(this._depth,o+1),this._size+=1),o+=1,h=h.children[y]}}putBins(e,t){for(const s of this.getNodes(t)){const r=e.get(s.id);r?r.merge(s):e.set(s.id,s.clone())}}getNodes(e){const t=[],{geohashBounds:s,level:r}=e;let i=this._root;for(;i!==null;){const n=i.depth,d=i.xNode,h=i.yNode;if(n>=r){t.push(i),i=i.next;continue}const o=Math.ceil((n+1)/2),a=Math.floor((n+1)/2),c=1-n%2,f=30-(3*o+2*a),_=30-(2*o+3*a),l=~((1<<f)-1),m=~((1<<_)-1),p=(s.xLL&l)>>f,g=(s.yLL&m)>>_,I=(s.xTR&l)>>f,y=(s.yTR&m)>>_,A=d<<3*c+2*(1-c),z=h<<2*c+3*(1-c),pe=A+8*c+4*(1-c),me=z+4*c+8*(1-c),ye=Math.max(A,p),xe=Math.max(z,g),Ie=Math.min(pe,I),ve=Math.min(me,y);let F=null,E=null;for(let D=xe;D<=ve;D++)for(let P=ye;P<=Ie;P++){const be=P-A+(D-z)*(8*c+4*(1-c)),M=i.children[be];M&&(F||(F=M,F.next=i.next),E&&(E.next=M),E=M,M.next=i.next)}i=F||i.next}return t}}let Qe=class extends ue{constructor(e){super(e),this._tree=new Ke(this._options.fields)}get usedMemory(){return this._tree.usedMemory}put(e){throw new Error("Geohash tree does not support put")}putBounded(e,t,s){const{geohashLevel:r,spatialReference:i}=this._options,n=Ze(t,s,r,i);n!=null&&this._tree.putBins(e,n)}_insert(e,t,s,r){const{geohashLevel:i,spatialReference:n}=this._options,d=L(t,s,i,n);d&&this._tree.insert(e,t,s,d[0],d[1],i,r)}},et=class $ extends ie{static from(e,t){if(e instanceof this){const s=new Set(t),r=e._indices.filter(i=>s.has(i));return new $(e._reader,r)}return new $(e.copy(),t)}constructor(e,t){super(e.metadata),this._currentIndex=-1,this._displayTransform=null,this._reader=e,this._indices=t}setTransformForDisplay(e){const t=this._reader.getInTransform();if(t==null)return void(this._displayTransform=X(e));const s=X(t),r=X(e),[i,n]=s.scale,[d,h]=s.translate,[o,a]=r.scale,[c,f]=r.translate,_=i/o,l=n/a,m=(d-c)/o,p=(h-f)/a;this._displayTransform={originPosition:"lowerLeft",scale:[1/_,1/l,1,1],translate:[-m/_,-p/l,0,0]}}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const e=new $(this._reader.copy(),this._indices);return e._currentIndex=this._currentIndex,e._displayTransform=this._displayTransform,e._processorAttributes=this._processorAttributes,e}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone(e){this._reader.contextTimeZone=e}get usedMemory(){return S+this._reader.usedMemory}setProcessorAttributes(e){this._processorAttributes=Object.assign(this._processorAttributes??{},e)}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._displayTransform?Z(this._displayTransform,this._reader.readXForDisplay()):this._reader.readXForDisplay()}readYForDisplay(){return this._displayTransform?J(this._displayTransform,this._reader.readYForDisplay()):this._reader.readYForDisplay()}readGeometryForDisplay(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform):this._reader.readGeometryForDisplay()}readCentroidForDisplay(){var t;const e=(t=this._reader.readCentroidForDisplay())==null?void 0:t.clone();if(e){const[s,r]=e.coords;this._displayTransform?(e.coords[0]=Z(this._displayTransform,s),e.coords[1]=J(this._displayTransform,r)):(e.coords[0]=s,e.coords[1]=r)}return e}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute(e,t=!1){const s=this._reader.readAttribute(e,t);return s==null&&this._processorAttributes?this._processorAttributes[e]:s}readAttributes(){return{...this._processorAttributes,...this._reader.readAttributes()}}joinAttributes(e){return this._reader.joinAttributes(e)}getBounds(e){return this._reader.getBounds(e)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId(e){return this._reader.setDisplayId(e)}setIndex(e){return this._reader.setIndex(e)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const e=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:(e&&{x:e.coords[0],y:e.coords[1]})??null}}readLegacyGeometryForDisplay(){const e=this.readGeometryForDisplay();return je(e,this.geometryType,!1,!1)}readGeometryArea(){var e;return this._displayTransform?((e=this._reader.readGeometryForDisplayTransformed(this._displayTransform))==null?void 0:e.area())??0:this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute(e,t){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field(e){return this._reader.field(e)}hasField(e){return this._reader.hasField(e)}setField(e,t){return this._reader.setField(e,t)}keys(){return this._reader.keys()}castToText(e=!1){return this._reader.castToText(e)}},_e=class{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._aggregateIndex=null,this._aggregateIndexHash=null,this._spatialIndex=null}get usedMemory(){let e=0;return e+=this.reader.underlyingMemory,this._aggregateIndex&&(e+=this._aggregateIndex.usedMemory),this._spatialIndex&&(e+=this._spatialIndex.usedMemory),e}registerOverrides(e){this.reader.registerOverrides(e),this.invalidate()}queryFeaturesInBounds(e){const t=this._getSpatialIndex().search(e);return et.from(this.reader,t)}getAggregateIndex(e){const t=JSON.stringify(e);if(t!==this._aggregateIndexHash){switch(this._aggregateIndexHash=t,e.type){case"grid":this._aggregateIndex=new Re(e);break;case"geohash":this._aggregateIndex=new Qe(e)}this._aggregateIndex.insert(this.reader,this.isTiled)}return this._aggregateIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=Ve.fromReader(this.reader)),this._spatialIndex}};const te=1e4,tt=1e3;class O{static async create(e){const{metadata:t,definitionExpression:s}=e,r=s?await Oe(s,t.fieldsIndex):null;return new O(t,r,s)}constructor(e,t,s){this.metadata=e,this._clause=t,this._definitionExpression=s}get hash(){return this._definitionExpression}testFeature(e){return this._clause==null||this._clause.testFeature(e)}}class G{constructor(){this.modified=new Map,this.removed=new Set}modify(e){this.modified.set(e.objectId,e),this.removed.has(e.objectId)&&this.removed.delete(e.objectId)}remove(e){this.modified.delete(e),this.removed.add(e)}get isEmpty(){return this.modified.size===0&&this.removed.size===0}applyWhereClause(e){const t=new G;for(const[s,r]of this.modified)e.testFeature(r)?t.modified.set(s,r):t.removed.add(r.objectId);for(const s of this.removed)t.removed.add(s);return t}}let st=class fe extends _e{constructor(e){super(),this._reader=e,this.chunkId="override",this.normalizedChunkId="override"}static fromFeatures(e,t){const s=Ee.fromOptimizedFeatures(e,t);return new fe(s)}get reader(){return this._reader}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}getTileReader(e){if(!this._reader.getSize())return null;const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}};class C{constructor(e,t){this.inner=e,this.isWeak=t,this.lastWeak=null}get isStrong(){return!this.isWeak}}class rt{constructor(e){this._parameters=e,this._overrides=new Map,this._update=new G,this._lastCleanup=0}update(e){this._parameters=e}hasOverride(e){return this._overrides.has(e)}onChunkInsert(e){var t;if(this._overrides.size){const s=e.reader.getCursor();for(;s.next();){const r=s.getObjectId(),i=this._overrides.get(r);if(i!=null&&i.lastWeak&&(i.lastWeak=null),i==null?void 0:i.isWeak){const n=s.readOptimizedFeatureWorldSpace(),d=((t=i.inner)==null?void 0:t.attributes)??{};n.attributes={...d,...n.attributes},i.inner=n,this._update.modify(n),this.invalidate()}}}e.registerOverrides(this)}apply(e,t){const{updateWeak:s,removeWeak:r,update:i,remove:n,release:d}=e.commands;this.invalidate();for(const h of s){const o=new C(h,!0),a=this._overrides.get(h.objectId);a!=null&&a.isStrong?a.lastWeak=o:(this._overrides.set(h.objectId,o),this._update.modify(h))}for(const h of i){const o=new C(h,!1),a=this._overrides.get(h.objectId);o.lastWeak=a!=null&&a.isWeak?a:(a==null?void 0:a.lastWeak)??null,this._overrides.set(h.objectId,o),this._update.modify(h)}for(const h of r){const o=new C(null,!0),a=this._overrides.get(h);a!=null&&a.isStrong?a.lastWeak=o:(this._overrides.set(h,o),this._update.remove(h))}for(const h of n){const o=new C(null,!1),a=this._overrides.get(h);o.lastWeak=a!=null&&a.isWeak?a:(a==null?void 0:a.lastWeak)??null,this._overrides.set(h,o),this._update.remove(h)}if(d.length){const h=new Set;for(const o of d){const a=this._overrides.get(o);a!=null&&a.lastWeak?(this._overrides.set(o,a.lastWeak),a.lastWeak.inner==null?this._update.remove(o):this._update.modify(a.lastWeak.inner)):a&&!a.isWeak&&(this._overrides.delete(o),h.add(o))}t.forEachUnsafe(o=>{const a=o.getObjectId();h.has(a)&&(this._update.modify(o.readOptimizedFeatureWorldSpace()),h.delete(a))});for(const o of h.values())this._update.remove(o)}}clearWeakOverrides(){for(const[e,t]of this._overrides.entries())t.isWeak&&this._overrides.delete(e);this.invalidate()}cleanup(e){if(this._overrides.size<te)return;const t=performance.now();if(t-this._lastCleanup<tt)return;this._lastCleanup=t;const s=this._getWeakDeletions();if(!(s.size<te)){for(const r of e){const i=r.reader.withoutOverrides().getCursor();for(;i.next();){const n=i.getObjectId();s.delete(n)}}for(const r of s)this._overrides.delete(r);s.size&&this.invalidate()}}takeOverrideUpdate(){const e=this._update;return e.isEmpty?null:(this._update=new G,e.applyWhereClause(this._parameters))}asChunk(){const e=this._parameters;if(this._lastOverrideParametersHash!==e.hash&&(this._lastOverrideParametersHash=e.hash,this._chunk=null),!this._chunk){const t=[];for(const s of this._overrides.values())s.inner!=null&&e.testFeature(s.inner)&&t.push(s.inner);this._chunk=st.fromFeatures(t,e.metadata)}return this._chunk}invalidate(){this._chunk=null}putWeakObjectIdsFromGlobalIds(e,t,s){for(const[r,i]of this._overrides.entries()){if(i.isWeak&&i.inner!=null){const n=i.inner.attributes[s];n&&t.has(n)&&!e.has(n)&&e.set(n,r);continue}if(i.lastWeak!=null&&i.lastWeak.inner!=null){const n=i.lastWeak.inner.attributes[s];n&&t.has(n)&&!e.has(n)&&e.set(n,r)}}}_getWeakDeletions(){const e=new Set;for(const[t,s]of this._overrides.entries())s.isWeak&&s.inner==null&&e.add(t);return e}}class ft extends _e{constructor(e,t,s,r,i=0){super(),this._reader=e,this._queryJSON=t,this._page=s,this._end=r,this._fileIndex=i,this.chunkId=`${this._fileIndex}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return this._page===0}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(e){const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}}let k;class ge extends ie{constructor(e,t,s,r,i,n=new Uint32Array(s.size())){super(e),this._fields=t,this._inner=s,this._chunkId=r,this._fileIndex=i,this._displayIds=n,this._index=-1,this.usedMemory=S,this._size=this._inner.size(),e.featureIdInfo.type,this._chunkId>65535&&console.error("Exceeded max allowed parquet reader size")}destroy(){super.destroy(),this._inner.free()}get fields(){return this._fields}get geometryType(){return this.metadata.geometryType}get hasFeatures(){return!0}get hasNext(){throw new Error("Method not implemented.")}get exceededTransferLimit(){return!1}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return null}getSize(){return this._size}getCursor(){return this.copy()}getAttributeHash(){let e="";for(const t of this.fields.fields)e+=this._readAttribute(t.name,!1)+".";return e}getObjectId(){return this._fileIndex<<24|this._inner.rowId(this._index)}getDisplayId(){return this._displayIds[this._index]}setDisplayId(e){this._displayIds[this._index]=e}setIndex(e){this._index=e}getBoundsXMin(){return this._inner.boundsXMin(this._index)}getBoundsYMin(){return this._inner.boundsYMin(this._index)}getBoundsXMax(){return this._inner.boundsXMax(this._index)}getBoundsYMax(){return this._inner.boundsYMax(this._index)}setBoundsXMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsXMax(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMax(e){throw new Error("InternalError: Setting bounds is unsupported")}getIndex(){return this._index}next(){for(;++this._index<this._size&&!this._getExists(););return this._index<this._size}readGeometryArea(){var e;return((e=this.readGeometryForDisplay())==null?void 0:e.area())??0}copy(){const e=new ge(this.metadata,this._fields,this._inner,this._chunkId,this._fileIndex,this._displayIds);return this.copyInto(e),e}copyInto(e){super.copyInto(e),e._index=this._index}readGeometryForDisplayTransformed(e){const[t,s]=e.translate,[r,i]=e.scale;return k||(k=Ae.new()),this._inner.transformGeometry(k,t,s,r,i,this._index)?new x(k.readLengthsUnsafe(),k.readCoordsUnsafe()):null}_readGeometry(e){const t=this._inner.readCoords(this._index),s=this._inner.readLengths(this._index);return t&&s?new x(s,t):null}_readX(){return this._inner.readX(this._index)}_readY(){return this._inner.readY(this._index)}_readServerCentroid(){return null}_readAttribute(e,t){const s=this.fields.get(e);if(!s)return;if(s.column==null)return this.getObjectId();const r=this._inner.readAttribute(this._index,s.column);if(r==null)return r;const i=this.fields.isDateField(s.name);return t?r==null?r:i?new Date(r):r:r}_readAttributes(){const e={};for(const t of this._fields.fields)t.column!=null&&(this._inner.isEmpty(t.column)||(e[t.name]=this._readAttribute(t.name,!1)));return e.__OBJECTID=this.getObjectId(),e}}class gt{constructor(){this._chunks=new Map,this._chunksToRemove=[],this.events=new Ge,this.featureAdapter=new De}destroy(){this.clear()}clear(){var e;for(const t of this._chunks.values())this._chunksToRemove.push(t);this._chunks.clear(),(e=this._overrides)==null||e.clearWeakOverrides()}get usedMemory(){let e=0;for(const t of this._chunks.values())e+=t.usedMemory;return e}async update(e){if(this._overrides){const t=await O.create(e);this._overrides.update(t)}this._schema=e}*chunks(){this._overrides&&(yield this._overrides.asChunk()),yield*this._chunks.values()}insert(e){var t;Y("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.insert`),(t=this._overrides)==null||t.onChunkInsert(e),this._chunks.set(e.chunkId,e),this.events.emit("changed")}remove(e){Y("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.remove`),this._chunks.delete(e.chunkId),this._chunksToRemove.push(e)}removeById(e){Y("esri-2d-update-debug")&&console.debug(`Chunk[${e}] SourceChunkStore.remove`);const t=this._chunks.get(e);this._chunks.delete(e),t&&this._chunksToRemove.push(t)}cleanup(){var t;const e=this._chunksToRemove;return this._chunksToRemove=[],(t=this._overrides)==null||t.cleanup(this._chunks.values()),e}async applyOverride(e){if(this._overrides==null){const t=await O.create(this._schema);this._overrides=new rt(t);for(const s of this._chunks.values())this._overrides.onChunkInsert(s)}this._overrides.apply(e,this),this.events.emit("changed");for(const t of this._chunks.values())t.invalidate()}takeOverrideUpdate(){var e;return(e=this._overrides)==null?void 0:e.takeOverrideUpdate()}refresh(){this.events.emit("refresh")}forEach(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r.copy()),t.add(i))}}}forEachUnsafe(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}mapObjectIdsFromGlobalIds(e,t){var i;const s=new Map,r=new Set(e);return(i=this._overrides)==null||i.putWeakObjectIdsFromGlobalIds(s,r,t),this._forEachUnsafeIgnoreOverrides(n=>{const d=n.readAttribute(t);if(d&&r.has(d)&&!s.has(d)){const h=n.getObjectId();s.set(d,h)}}),s}forEachInBounds(e,t){const s=new Set;for(const r of this.chunks()){const i=r.queryFeaturesInBounds(e);for(;i.next();){const n=i.getObjectId();s.has(n)||(t(i.copy()),s.add(n))}}}forEachBounds(e,t){const s=se();for(const r of e)r.getBounds(s)&&t(s)}_forEachUnsafeIgnoreOverrides(e){const t=new Set;for(const s of this._chunks.values()){const r=s.reader.withoutOverrides().getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}}export{st as a,B as b,_e as c,et as d,ge as i,b as l,gt as n,qe as r,ft as t};
