const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./containsOperator.js","./ProjectionTransformation.js","./Point2D.js","./Envelope2D.js","./Transformation2D.js","./ShadowCastClear.glsl.js","./iframe-DwvN93Ge.js","./iframe-CGchYWp9.css","./index.js","./Viewport.js","./Section.js","./ErrorBoundary.js","./createClass.js","./Global.js","./useIsDark.js","./debounce.js","./index2.js","./ShadowCastClear-Cq39gfL_.css","./OperatorDefinitions.js","./jsonConverter.js","./apiConverter.js","./intersectsOperator.js","./OperatorIntersects.js","./intersectionOperator2.js","./operatorIntersection.js","./simplifyOperator2.js","./operatorSimplify.js"])))=>i.map(i=>d[i]);
import{b8 as P}from"./iframe-DwvN93Ge.js";import{eo as I,hF as C,b0 as F,b as M,ap as G,en as S,lx as V,l as R,E as x,F as L,V as U}from"./ShadowCastClear.glsl.js";import{s as j,a as z}from"./LercDecoder.js";import{l as k}from"./LayerView3D.js";import{p as Z}from"./TiledLayerView3D.js";import{d as B}from"./LayerView.js";import"./index.js";import"./Viewport.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";import"./debounce.js";import"./index2.js";class H{constructor(){this.modifications=[]}async apply(o,t,e){if(this.modifications.length!==0&&(b??(b=Promise.all([P(()=>import("./containsOperator.js").then(i=>i.c),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]),import.meta.url),P(()=>import("./intersectsOperator.js").then(i=>i.i),__vite__mapDeps([21,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,22,20]),import.meta.url),P(()=>import("./intersectionOperator2.js").then(i=>i.i),__vite__mapDeps([23,5,6,7,8,9,10,11,12,13,14,15,16,17,2,1,3,4,18,19,24,20]),import.meta.url)])),O=await b,!I(e)))for(const i of this.modifications)i.apply(o,t)}}class J{constructor(o,t){this.type=o,this.polygon=t}apply(o,t){if(this.type!=="replace")return;const{polygon:e}=this,[i,a,l]=O,{extent:p,spatialReference:d}=t,_=C(p,d);if(a.accelerateGeometry(e),!a.execute(e,_))return;i.accelerateGeometry(e),l.accelerateGeometry(e);const{width:s,height:m,values:h}=o,g=e.hasZ?e.rings.reduce((n,y)=>y.reduce((c,u)=>Math.min(c,u[2]??1/0),n),1/0):1/0,f=g===1/0?0:g;if(i.execute(e,_))h.fill(f);else{const n=K(t,e,[s,m]);if(!n||n.rings.every(c=>c.length===0))return;const y=N(t,n,s,m);for(let c=m-1;c>=0;--c)for(let u=0;u<s;++u){const E=(c+1)*(s+2)+(u+1);let w=0;for(let T=-1;T<=1;++T){const q=E+T*(s+2);for(let $=-1;$<=1;++$)w=Math.max(w,y[q+$])}const D=c*s+u;h[D]=w===0?h[D]:f}}}}let b,O;function K(r,o,t){const[e,i,a,l]=r.extent,{spatialReference:p}=r,[d,_]=t,s=2,m=(a-e)/(d-1),h=(l-i)/(_-1),g=new F({xmin:e-s*m,ymin:i-s*h,xmax:a+s*m,ymax:l+s*h,spatialReference:p}),f=O[2].execute(o,g);return(f==null?void 0:f.type)==="polygon"?f:null}function N(r,o,t,e){const i=new OffscreenCanvas(t+2,e+2).getContext("2d",{willReadFrequently:!0});if(!i)throw new Error("failed to create canvas");const[a,l,p,d]=r.extent,_=p-a,s=d-l;i.fillStyle="black",i.clearRect(0,0,t,e);const m=new Path2D;for(const n of o.rings)if(n.length>0){const y=new Path2D;let c=!0;for(const[u,E]of n){const w=(u-a)/_*(t-1)+1+A,D=(d-E)/s*(e-1)+1+A;c?(c=!1,y.moveTo(w,D)):y.lineTo(w,D)}y.closePath(),m.addPath(y)}i.fillStyle="white",i.fill(m,"evenodd");const h=i.getImageData(0,0,t+2,e+2),g=(t+2)*(e+2),f=new Uint8Array(g);for(let n=0;n<g;++n)f[n]=h.data[4*n+0]>0?1:0;return f}const A=.5;let v=class extends Z(k(B)){constructor(){super(...arguments),this.type="elevation-3d",this.modifications=new H}get tileInfo(){return this.layer.tileInfo}initialize(){var a,l,p;const r=this.view,o=(a=r.map)==null?void 0:a.allLayers,t=o&&o.includes(this.layer),e=(p=(l=r.map)==null?void 0:l.ground)==null?void 0:p.layers,i=e&&e.includes(this.layer);if(t&&!i){const d=new M("layerview:elevation-layer-only",`3D elevation layer '${this.layer.id}' can only be added to layers in map.ground`);this.addResolvingPromise(Promise.reject(d))}this._lercDecoder=j(r.resourceController),this._addTilingSchemeMatchPromise()}destroy(){this._lercDecoder=G(this._lercDecoder)}async fetchElevationTile(r,o){const t=await this._fetchTileData(r.lij,o);if(!I(o))return t&&await this.modifications.apply(t,r,o.signal),t}async _fetchTileData(r,o){const t=this.layer;if(S(t)){const l=await t.fetchTile(r[0],r[1],r[2],{noDataValue:V,signal:o.signal});return I(o)?void R.getLogger(this).warnOnce("A call to fetchTile resolved even though the request was aborted. fetchTile should not resolve if options.signal.aborted is true."):l}const e=this.getTileUrl(r),i=await o.requester.request(e,1,o),a=await this._lercDecoder.decode(i,{noDataValue:V},o.signal);if(a)return new z(a);throw new Error("LERC decoding failed")}async setModifications(r){if(this.modifications.modifications.length=0,!r||r.length===0)return;this._simplifyOperatorPromise??(this._simplifyOperatorPromise=P(()=>import("./simplifyOperator2.js").then(t=>t.s),__vite__mapDeps([25,2,1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,26,20]),import.meta.url));const o=await this._simplifyOperatorPromise;for(const t of r){const e=t.geometry;if((e==null?void 0:e.type)==="polygon"){const i=o.execute(e);if((i==null?void 0:i.type)==="polygon"){const a=new J(t.type,i);this.modifications.modifications.push(a)}else R.getLogger(this).warn("Failed to simplify modification polygon")}else R.getLogger(this).warn("Invalid modification added to elevation layer: "+(e?`non polygon geometry ${e.type}`:"no geometry"))}}};x([L()],v.prototype,"layer",void 0),x([L()],v.prototype,"tileInfo",null),x([L()],v.prototype,"modifications",void 0),v=x([U("esri.views.3d.layers.ElevationLayerView3D")],v);const me=v;export{me as default};
