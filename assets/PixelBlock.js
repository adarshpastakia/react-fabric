import{D as v,b as B,i as T,l as k,E as x,F as m,he as C,V as M}from"./ShadowCastClear.glsl.js";import{u as U}from"./pixelRangeUtils.js";class w{constructor(e=null,a=null,n=null){this.minValue=e,this.maxValue=a,this.noDataValue=n}}var A;let d=A=class extends v{static createEmptyBand(t,e){return new(A.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,a=new Uint8Array(e).fill(255);for(let n=0;n<t.length;n++){const r=t[n];for(let i=0;i<e;i++)r[i]||(a[i]=0)}return a}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){var t;return(t=this.pixels)==null?void 0:t.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new B("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new w)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(a=>V(a,this.mask));const t=this.mask;let e=0;if(t!=null)for(let a=0;a<t.length;a++)t[a]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,a]=U(t),n=this.pixels,r=this.width*this.height,i=n.length;let s,o,l;const f=[];for(let u=0;u<i;u++){l=A.createEmptyBand(t,r),s=n[u];for(let c=0;c<r;c++)o=s[c],l[c]=o>a?a:o<e?e:o;f.push(l)}this.pixels=f,this.pixelType=t}extractBands(t){var c;const{pixels:e,statistics:a}=this;if(t==null||t.length===0||!e||e.length===0)return this;const n=e.length,r=t.some(p=>p>=e.length),i=n===t.length&&!t.some((p,h)=>p!==h);if(r||i)return this;const s=((c=this.bandMasks)==null?void 0:c.length)===n?t.map(p=>this.bandMasks[p]):void 0;let{mask:o,validPixelCount:l}=this;const{width:f,height:u}=this;return s!=null&&s.length&&(o=A.combineBandMasks(s),l=o.filter(p=>!!p).length),new A({pixelType:this.pixelType,width:f,height:u,mask:o,bandMasks:s,validPixelCount:l,maskIsAlpha:this.maskIsAlpha,pixels:t.map(p=>e[p]),statistics:a&&t.map(p=>a[p])})}clone(){const t=new A({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(n=>new Uint8Array(n)));const a=A.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const n=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=n?this.pixels[e].slice():new a(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=T(this.statistics[e]);return t}getTransferableObject(){const{pixels:t,bandMasks:e,mask:a}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const n=this.toJSON();this.pixels=t,this.bandMasks=e,this.mask=a,n.pixels=t&&[...t],n.bandMasks=e&&[...e],n.mask=a;const r=[];return[...t??[],a,...e??[]].filter(i=>i!=null&&ArrayBuffer.isView(i)).forEach(i=>{i&&!r.includes(i.buffer)&&r.push(i.buffer)}),{pixelBlock:n,transferList:r}}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:a,premultiplyAlpha:n,pixels:r}=this;if(!t||!(r!=null&&r.length))return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let i,s,o,l;i=s=o=r[0],r.length>=3?(s=r[1],o=r[2]):r.length===2&&(s=r[1]);const f=new Uint32Array(t),u=this.width*this.height;if(i.length===u)if(e!=null&&e.length===u)if(a)for(l=0;l<u;l++){const c=e[l];if(c){const p=c/255;f[l]=n?c<<24|o[l]*p<<16|s[l]*p<<8|i[l]*p:c<<24|o[l]<<16|s[l]<<8|i[l]}}else for(l=0;l<u;l++)e[l]&&(f[l]=255<<24|o[l]<<16|s[l]<<8|i[l]);else for(l=0;l<u;l++)f[l]=255<<24|o[l]<<16|s[l]<<8|i[l];else k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:a,statistics:n}=this;if(!t||!(e!=null&&e.length))return void k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let i=1,s=0,o=1;if(n&&n.length>0){for(const g of n)if(g.minValue!=null&&(s=Math.min(s,g.minValue)),g.maxValue!=null&&g.minValue!=null){const b=g.maxValue-g.minValue;o=Math.max(o,b)}i=255/o}else{let g=255;r==="s8"?(s=-128,g=127):r==="u16"?g=65535:r==="s16"?(s=-32768,g=32767):r==="u32"?g=4294967295:r==="s32"?(s=-2147483648,g=2147483647):r==="f32"?(s=-34e38,g=34e38):r==="f64"&&(s=-Number.MAX_VALUE,g=Number.MAX_VALUE),i=255/(g-s)}const l=new Uint32Array(t),f=this.width*this.height;let u,c,p,h,y;if(u=c=p=e[0],u.length!==f)return k.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(c=e[1],e.length>=3&&(p=e[2]),a!=null&&a.length===f)for(h=0;h<f;h++)a[h]&&(l[h]=255<<24|(p[h]-s)*i<<16|(c[h]-s)*i<<8|(u[h]-s)*i);else for(h=0;h<f;h++)l[h]=255<<24|(p[h]-s)*i<<16|(c[h]-s)*i<<8|(u[h]-s)*i;else if(a!=null&&a.length===f)for(h=0;h<f;h++)y=(u[h]-s)*i,a[h]&&(l[h]=255<<24|y<<16|y<<8|y);else for(h=0;h<f;h++)y=(u[h]-s)*i,l[h]=255<<24|y<<16|y<<8|y}_fillFrom32Bit(t){const{pixels:e,mask:a}=this;if(!t||!(e!=null&&e.length))return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let n,r,i,s;n=r=i=e[0],e.length>=3?(r=e[1],i=e[2]):e.length===2&&(r=e[1]);const o=this.width*this.height;if(n.length!==o)return k.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let l=0;if(a!=null&&a.length===o)for(s=0;s<o;s++)t[l++]=n[s],t[l++]=r[s],t[l++]=i[s],t[l++]=1&a[s];else for(s=0;s<o;s++)t[l++]=n[s],t[l++]=r[s],t[l++]=i[s],t[l++]=1}};function V(t,e){let a=1/0,n=-1/0;const r=t.length;let i,s=0;if(e!=null)for(i=0;i<r;i++)e[i]&&(s=t[i],a=s<a?s:a,n=s>n?s:n);else for(i=0;i<r;i++)s=t[i],a=s<a?s:a,n=s>n?s:n;return new w(a,n)}x([m({json:{write:!0}})],d.prototype,"width",void 0),x([m({json:{write:!0}})],d.prototype,"height",void 0),x([m({json:{write:!0}})],d.prototype,"pixelType",void 0),x([C("pixelType")],d.prototype,"castPixelType",null),x([m({json:{write:!0}})],d.prototype,"validPixelCount",void 0),x([m({json:{write:!0}})],d.prototype,"mask",void 0),x([m({json:{write:!0}})],d.prototype,"maskIsAlpha",void 0),x([m({json:{write:!0}})],d.prototype,"pixels",void 0),x([m()],d.prototype,"premultiplyAlpha",void 0),x([m({json:{write:!0}})],d.prototype,"statistics",void 0),x([m({json:{write:!0}})],d.prototype,"depthCount",void 0),x([m({json:{write:!0}})],d.prototype,"noDataValues",void 0),x([m({json:{write:!0}})],d.prototype,"bandMasks",void 0),d=A=x([M("esri.layers.support.PixelBlock")],d);export{d as c,w as l};
