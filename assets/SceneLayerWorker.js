const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./ShadowCastClear.glsl.js","./iframe-DpfJK_wQ.js","./iframe-DPR8S5X3.css","./index.js","./Viewport.js","./debounce.js","./index2.js","./Section.js","./ErrorBoundary.js","./createClass.js","./Global.js","./useIsDark.js","./ShadowCastClear-BxU8WlBI.css","./projectMeshVertexPositions.js","./vertexSpaceConversion.js","./vec4.js"])))=>i.map(i=>d[i]);
import{b6 as x}from"./iframe-DpfJK_wQ.js";import{co as q,K as D,lH as z,lI as K,i3 as k,lJ as G,kq as Q,lK as W,lL as X}from"./ShadowCastClear.glsl.js";import{n as Z,h as ee}from"./I3SMeshWorkerHandle.js";import"./index.js";import"./Viewport.js";import"./debounce.js";import"./index2.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";function te(){return F??(F=(async()=>await(await x(()=>import("./i3s.js"),[],import.meta.url)).default({locateFile:t=>q(`esri/libs/i3s/${t}`)}))()),F}function re(){F=null}let F;async function he(e){o=await g();const t=[e.geometryBuffer];return{result:V(o,e,t),transferList:t}}async function ge(e){var c;o=await g();const t=[e.geometryBuffer],{geometryBuffer:r}=e,a=r.byteLength,s=o._malloc(a),l=new Uint8Array(o.HEAPU8.buffer,s,a);l.set(new Uint8Array(r));const f=o.dracoDecompressPointCloudData(s,l.byteLength);if(o._free(s),f.error.length>0)throw new Error(`i3s.wasm: ${f.error}`);const m=((c=f.featureIds)==null?void 0:c.length)>0?f.featureIds.slice():null,y=f.positions.slice();return m&&t.push(m.buffer),t.push(y.buffer),{result:{positions:y,featureIds:m},transferList:t}}async function we(e){await g(),ne(e);const t={buffer:e.buffer};return{result:t,transferList:[t.buffer]}}async function Ee(e){await g(),oe(e)}async function _e(e){o=await g(),o.setLegacySchema(e.context,e.jsonSchema)}async function Ae(e){const{localMatrix:t,origin:r,positions:a,vertexSpace:s}=e,l=D.fromJSON(e.inSpatialReference),f=D.fromJSON(e.outSpatialReference),m=t?z(t):void 0,y=K(r);let c;const[{projectBuffer:_},{initializeProjection:O}]=await Promise.all([x(()=>import("./ShadowCastClear.glsl.js").then(i=>i.Jq),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12]),import.meta.url),x(()=>import("./ShadowCastClear.glsl.js").then(i=>i.Jr),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12]),import.meta.url)]);await O(l,f);const p=[0,0,0];if(!_(y,l,0,p,f,0))throw new Error("Failed to project");if(s.type==="georeferenced"&&s.origin==null){if(c=new Float64Array(a.length),!_(a,l,0,c,f,0,c.length/3))throw new Error("Failed to project")}else{const i=s.type==="georeferenced"?k.fromJSON(s):G.fromJSON(s),{projectMeshVertexPositions:d}=await x(async()=>{const{projectMeshVertexPositions:T}=await import("./projectMeshVertexPositions.js");return{projectMeshVertexPositions:T}},__vite__mapDeps([13,0,1,2,3,4,5,6,7,8,9,10,11,12,14,15]),import.meta.url),E=d({vertexAttributes:{position:a},transform:m?{localMatrix:m}:void 0,vertexSpace:i,spatialReference:l},f);if(!E)throw new Error("Failed to project");c=E}const A=c.length,[w,L,u]=p;for(let i=0;i<A;i+=3)c[i]-=w,c[i+1]-=L,c[i+2]-=u;return{result:{projected:c,original:a,projectedOrigin:p},transferList:[c.buffer,a.buffer]}}async function Le({normalMatrix:e,normals:t}){const r=new Float32Array(t.length);return Q(r,t,e),W(e)&&X(r,r),{result:{transformed:r,original:t},transferList:[r.buffer,t.buffer]}}function Pe(e){J(e)}let $,o;function oe(e){if(!o)return;const t=e.modifications,r=o._malloc(8*t.length),a=new Float64Array(o.HEAPU8.buffer,r,t.length);for(let s=0;s<t.length;++s)a[s]=t[s];o.setModifications(e.context,r,t.length,e.isGeodetic),o._free(r)}function V(e,t,r){const{context:a,globalTrafo:s,mbs:l,obbData:f,elevationOffset:m,geometryBuffer:y,geometryDescriptor:c,indexToVertexProjector:_,vertexToRenderProjector:O}=t,p=e._malloc(y.byteLength),A=33,w=e._malloc(A*Float64Array.BYTES_PER_ELEMENT),L=new Uint8Array(e.HEAPU8.buffer,p,y.byteLength);L.set(new Uint8Array(y));const u=new Float64Array(e.HEAPU8.buffer,w,A);P(u,[NaN,NaN,NaN]);let i=u.byteOffset+3*u.BYTES_PER_ELEMENT,d=new Float64Array(u.buffer,i);P(d,s),i+=16*u.BYTES_PER_ELEMENT,d=new Float64Array(u.buffer,i),P(d,l),i+=4*u.BYTES_PER_ELEMENT,f&&(d=new Float64Array(u.buffer,i),P(d,f));const E=c,T={isDraco:!1,isLegacy:!1,color:t.layouts.some(b=>b.some(h=>h.name==="color")),normal:t.needNormals&&t.layouts.some(b=>b.some(h=>h.name==="normalCompressed")),uv0:t.layouts.some(b=>b.some(h=>h.name==="uv0")),uvRegion:t.layouts.some(b=>b.some(h=>h.name==="uvRegion")),featureIndex:E.featureIndex},n=e.process(a,!!t.obbData,p,L.byteLength,E,T,w,m,_,O,t.normalReferenceFrame);if(e._free(w),e._free(p),n.error.length>0)throw new Error(`i3s.wasm: ${n.error}`);if(n.discarded)return null;const M=n.componentOffsets.length>0?n.componentOffsets.slice():null,S=n.featureIds.length>0?n.featureIds.slice():null,H=n.anchorIds.length>0?Array.from(n.anchorIds):null,C=n.anchors.length>0?Array.from(n.anchors):null,N=n.interleavedVertedData.slice().buffer,v=n.indicesType===1?new Uint16Array(n.indices.buffer,n.indices.byteOffset,n.indices.byteLength/2).slice():new Uint32Array(n.indices.buffer,n.indices.byteOffset,n.indices.byteLength/4).slice(),I=n.positions.slice(),{buffer:R,byteOffset:j,byteLength:U}=n.positionIndices,B=n.positionIndicesType===1?new Uint16Array(R,j,U/2).slice():new Uint32Array(R,j,U/4).slice(),Y=new Z(t.layouts[0],N,v,n.hasColors,n.hasModifications,{data:I,indices:B});return S&&r.push(S.buffer),M&&r.push(M.buffer),r.push(N),r.push(v.buffer),r.push(I.buffer),r.push(B.buffer),new ee(M,S,H,C,Y,s,n.obb)}function xe(e){return e===0?0:e===1?1:e===2?2:3}function ne(e){if(!o)return;const{context:t,buffer:r}=e,a=o._malloc(r.byteLength),s=r.byteLength/Float64Array.BYTES_PER_ELEMENT,l=new Float64Array(o.HEAPU8.buffer,a,s),f=new Float64Array(r);l.set(f),o.filterOBBs(t,a,s),f.set(l),o._free(a)}function J(e){o&&o.destroy(e)===0&&(o=null,$=null,re())}function P(e,t){for(let r=0;r<t.length;++r)e[r]=t[r]}async function Oe(){o||await g()}async function g(){return o||(o=await($??($=te()))),o}const Te={transform:(e,t)=>o&&V(o,e,t),destroy:J};export{Pe as destroyContext,ge as dracoDecompressPointCloudData,we as filterObbsForModifications,ne as filterObbsForModificationsSync,Oe as initialize,xe as interpretObbModificationResults,he as process,Ae as project,_e as setLegacySchema,Ee as setModifications,oe as setModificationsSync,Te as test,Le as transformNormals};
