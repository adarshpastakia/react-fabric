const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./GroupLayer.js","./iframe-DpfJK_wQ.js","./iframe-DPR8S5X3.css","./ShadowCastClear.glsl.js","./index.js","./Viewport.js","./debounce.js","./index2.js","./Section.js","./ErrorBoundary.js","./createClass.js","./Global.js","./useIsDark.js","./ShadowCastClear-BxU8WlBI.css","./layersCreator.js","./loadUtils.js","./fetchService.js","./associatedFeatureServiceUtils.js","./lazyLayerLoader.js","./portalLayers.js"])))=>i.map(i=>d[i]);
import{b6 as F}from"./iframe-DpfJK_wQ.js";import{p as _,b as v,aw as C,ax as V,ay as $,az as N,w as g}from"./ShadowCastClear.glsl.js";import{s as J}from"./associatedFeatureServiceUtils.js";import{t as p,l as S,n as k}from"./fetchService.js";import{a as x}from"./lazyLayerLoader.js";import"./index.js";import"./Viewport.js";import"./debounce.js";import"./index2.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";const E={FeatureLayer:!0,SceneLayer:!0,VideoLayer:!0};async function le(e){const{properties:s,url:r}=e,t={...s,url:r},o=await D(r,s==null?void 0:s.customParameters),{Constructor:a,layerId:i,sourceJSON:u,parsedUrl:y,layers:n,tables:d}=o;if(n.length+d.length===0)return i!=null&&(t.layerId=i),u!=null&&(t.sourceJSON=u),new a(t);const m=new(await F(async()=>{const{default:w}=await import("./GroupLayer.js");return{default:w}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]),import.meta.url)).default({title:y.title});return await M(m,o,t),m}function U(e,s){return e?e.find(({id:r})=>r===s):null}function O(e,s,r,t,o){const a={...o,layerId:s};return e!=null&&(a.url=e),r!=null&&(a.sourceJSON=r),"sublayerTitleMode"in t.prototype&&(a.sublayerTitleMode="service-name"),new t(a)}async function M(e,s,r){const t=s.sublayerConstructorProvider;for(const{id:o,serverUrl:a}of s.layers){const i=U(s.sublayerInfos,o),u=O(a,o,i,(i&&(t==null?void 0:t(i)))??s.Constructor,r);e.add(u)}if(s.tables.length){const o=await b("FeatureLayer");s.tables.forEach(({id:a,serverUrl:i})=>{const u=O(i,a,U(s.tableInfos,a),o,r);e.tables.add(u)})}}async function D(e,s){var d,m,w,h,I,L,P;let r=_(e);if(r==null&&(r=await G(e,s)),r==null)throw new v("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:e});const{serverType:t,sublayer:o}=r;let a;const i={FeatureServer:"FeatureLayer",KnowledgeGraphServer:"KnowledgeGraphLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer",VideoServer:"VideoLayer"},u=t==="FeatureServer",y=t==="SceneServer",n={parsedUrl:r,Constructor:null,layerId:u||y?o??void 0:void 0,layers:[],tables:[]};switch(t){case"MapServer":if(o!=null){const{type:l}=await p(e,{customParameters:s});switch(a="FeatureLayer",l){case"Catalog Layer":a="CatalogLayer";break;case"Catalog Dynamic Group Layer":throw new v("arcgis-layers:unsupported",`fromUrl() not supported for "${l}" layers`)}}else a=await z(e,s)?"TileLayer":"MapImageLayer";break;case"ImageServer":{const l=await p(e,{customParameters:s}),{tileInfo:c,cacheType:f}=l;a=c?((d=c==null?void 0:c.format)==null?void 0:d.toUpperCase())!=="LERC"||f&&f.toLowerCase()!=="elevation"?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const l=await p(r.url.path,{customParameters:s});if(a="SceneLayer",l){const c=l==null?void 0:l.layers;if((l==null?void 0:l.layerType)==="Voxel")a="VoxelLayer";else if(c!=null&&c.length){const f=(m=c[0])==null?void 0:m.layerType;f!=null&&g[f]!=null&&(a=g[f])}}break}case"3DTilesServer":throw new v("arcgis-layers:unsupported","fromUrl() not supported for 3DTiles layers");case"FeatureServer":if(a="FeatureLayer",o!=null){const l=await p(e,{customParameters:s});n.sourceJSON=l,n.preferredUrl=C(),a=S(l.type)}break;default:a=i[t]}if(E[a]&&o==null){const l=await K(e,t,s);if(u&&(n.preferredUrl=l.preferredUrl,n.sublayerInfos=l.layerInfos,n.tableInfos=l.tableInfos),l.layers.length+l.tables.length!==1)n.layers=l.layers,n.tables=l.tables,u&&((w=l.layerInfos)!=null&&w.length)&&(n.sublayerConstructorProvider=await A(l.layerInfos));else if(u||y){const c=((h=l.layerInfos)==null?void 0:h[0])??((I=l.tableInfos)==null?void 0:I[0]);if(n.layerId=((L=l.layers[0])==null?void 0:L.id)??((P=l.tables[0])==null?void 0:P.id),n.sourceJSON=c,u){const f=c==null?void 0:c.type;a=S(f)}}}return n.Constructor=await b(a),n}async function G(e,s){var u;const r=await p(e,{customParameters:s});let t=null,o=null;const a=r.type;if(a==="Feature Layer"||a==="Table"?(t="FeatureServer",o=r.id??null):a==="indexedVector"?t="VectorTileServer":r.hasOwnProperty("mapName")?t="MapServer":r.hasOwnProperty("bandCount")&&r.hasOwnProperty("pixelSizeX")?t="ImageServer":r.hasOwnProperty("maxRecordCount")&&r.hasOwnProperty("allowGeometryUpdates")?t="FeatureServer":r.hasOwnProperty("streamUrls")?t="StreamServer":T(r)?(t="SceneServer",o=r.id):r.hasOwnProperty("layers")&&T((u=r.layers)==null?void 0:u[0])&&(t="SceneServer"),!t)return null;const i=o!=null?V(e):null;return{title:i!=null&&r.name||N(e),serverType:t,sublayer:o,url:{path:i!=null?i.serviceUrl:$(e).path}}}function T(e){return e!=null&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&typeof e.id=="number"}async function K(e,s,r){let t,o,a,i=!1;switch(s){case"FeatureServer":{const n=await k(e,{customParameters:r});a=C(e,{preferredHost:n.preferredHost}),i=!!n.layersJSON,t=n.layersJSON||n.serviceJSON;break}case"SceneServer":{const n=await R(e,r);t=n.serviceInfo,o=n.tableServerUrl;break}default:t=await p(e,{customParameters:r})}const u=t==null?void 0:t.layers,y=t==null?void 0:t.tables;return{preferredUrl:a,layers:(u==null?void 0:u.map(n=>({id:n.id})).reverse())||[],tables:(y==null?void 0:y.map(n=>({serverUrl:o,id:n.id})).reverse())||[],layerInfos:i?u:[],tableInfos:i?y:[]}}async function R(e,s){var o;const r=await p(e,{customParameters:s});if(!((o=r.layers)==null?void 0:o[0]))return{serviceInfo:r};try{const{serverUrl:a}=await J(e),i=await p(a,{customParameters:s}).catch(()=>null);return i&&(r.tables=i.tables),{serviceInfo:r,tableServerUrl:a}}catch{return{serviceInfo:r}}}async function b(e){return(0,x[e])()}async function z(e,s){return(await p(e,{customParameters:s})).tileInfo}async function A(e){if(!e.length)return;const s=new Set,r=[];for(const{type:a}of e)s.has(a)||(s.add(a),r.push(b(S(a))));const t=await Promise.all(r),o=new Map;return Array.from(s).forEach((a,i)=>{o.set(a,t[i])}),a=>o.get(a.type)}export{le as fromUrl};
