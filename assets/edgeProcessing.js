import{e as H}from"./deduplicate.js";import{bK as q,bJ as D,fW as J,oa as _,fo as K,eF as R,iu as O}from"./ShadowCastClear.glsl.js";import{RegularEdgeInstancesLayout as P,SilhouetteEdgeInstancesLayout as Q,EdgeInputBufferLayout as j}from"./bufferLayouts.js";import"./iframe-qDaPDssc.js";import"./index.js";import"./Viewport.js";import"./debounce.js";import"./index2.js";import"./Section.js";import"./ErrorBoundary.js";import"./createClass.js";import"./Global.js";import"./useIsDark.js";function U(e,n,s){const i=n/3,c=new Uint32Array(s+1),u=new Uint32Array(s+1),l=(t,o)=>{t<o?c[t+1]++:u[o+1]++};for(let t=0;t<i;t++){const o=e[3*t],a=e[3*t+1],r=e[3*t+2];l(o,a),l(a,r),l(r,o)}let I=0,E=0;for(let t=0;t<s;t++){const o=c[t+1],a=u[t+1];c[t+1]=I,u[t+1]=E,I+=o,E+=a}const f=new Uint32Array(6*i),m=c[s],B=(t,o,a)=>{if(t<o){const r=c[t+1]++;f[2*r]=o,f[2*r+1]=a}else{const r=u[o+1]++;f[2*m+2*r]=t,f[2*m+2*r+1]=a}};for(let t=0;t<i;t++){const o=e[3*t],a=e[3*t+1],r=e[3*t+2];B(o,a,t),B(a,r,t),B(r,o,t)}const W=(t,o)=>{const a=2*t,r=o-t;for(let p=1;p<r;p++){const w=f[a+2*p],y=f[a+2*p+1];let d=p-1;for(;d>=0&&f[a+2*d]>w;d--)f[a+2*d+2]=f[a+2*d],f[a+2*d+3]=f[a+2*d+1];f[a+2*d+2]=w,f[a+2*d+3]=y}};for(let t=0;t<s;t++)W(c[t],c[t+1]),W(m+u[t],m+u[t+1]);const v=new Int32Array(3*i),N=(t,o)=>t===e[3*o]?0:t===e[3*o+1]?1:t===e[3*o+2]?2:-1,L=(t,o)=>{const a=N(t,o);v[3*o+a]=-1},k=(t,o,a,r)=>{const p=N(t,o);v[3*o+p]=r;const w=N(a,r);v[3*r+w]=o};for(let t=0;t<s;t++){let o=c[t];const a=c[t+1];let r=u[t];const p=u[t+1];for(;o<a&&r<p;){const w=f[2*o],y=f[2*m+2*r];w===y?(k(t,f[2*o+1],y,f[2*m+2*r+1]),o++,r++):w<y?(L(t,f[2*o+1]),o++):(L(y,f[2*m+2*r+1]),r++)}for(;o<a;)L(t,f[2*o+1]),o++;for(;r<p;)L(f[2*m+2*r],f[2*m+2*r+1]),r++}return v}const b=.7;let V=class{updateSettings(n){this.settings=n,this._edgeHashFunction=n.reducedPrecision?G:z}write(n,s,i){A.seed=this._edgeHashFunction(i);const c=A.getIntRange(0,255),u=A.getIntRange(0,this.settings.variants-1),l=A.getFloat(),I=255*(.5*T(-(1-Math.min(l/b,1))+Math.max(0,l-b)/(1-b),1.2)+.5);n.position0.setVec(s,i.position0),n.position1.setVec(s,i.position1),n.componentIndex.set(s,i.componentIndex),n.variantOffset.set(s,c),n.variantStroke.set(s,u),n.variantExtension.set(s,I)}};const g=new Float32Array(6),h=new Uint32Array(g.buffer),$=new Uint32Array(1);function z(e){return g[0]=e.position0[0],g[1]=e.position0[1],g[2]=e.position0[2],g[3]=e.position1[0],g[4]=e.position1[1],g[5]=e.position1[2],$[0]=31*(31*(31*(31*(31*(166811+h[0])+h[1])+h[2])+h[3])+h[4])+h[5],$[0]}function G(e){const n=g;n[0]=x(e.position0[0]),n[1]=x(e.position0[1]),n[2]=x(e.position0[2]),n[3]=x(e.position1[0]),n[4]=x(e.position1[1]),n[5]=x(e.position1[2]),$[0]=5381;for(let s=0;s<h.length;s++)$[0]=31*$[0]+h[s];return $[0]}const C=1e4;function x(e){return Math.round(e*C)/C}function T(e,n){return Math.abs(e)**n*Math.sign(e)}class X{constructor(){this._commonWriter=new V}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return P.createBuffer(n)}write(n,s,i){this._commonWriter.write(n,s,i),q(S,i.faceNormal0,i.faceNormal1),J(S,S);const{typedBuffer:c,typedBufferStride:u}=n.normalCompressed;_(c,s,S[0],S[1],S[2],u)}}class Y{constructor(){this._commonWriter=new V}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return Q.createBuffer(n)}write(n,s,i){this._commonWriter.write(n,s,i);{const{typedBuffer:c,typedBufferStride:u}=n.normalCompressed;_(c,s,i.faceNormal0[0],i.faceNormal0[1],i.faceNormal0[2],u)}{const{typedBuffer:c,typedBufferStride:u}=n.normal2Compressed;_(c,s,i.faceNormal1[0],i.faceNormal1[1],i.faceNormal1[2],u)}}}const S=D(),A=new K;function gt(e){const n=Z(e.data,e.skipDeduplicate,e.indices,e.indicesLength);return F.updateSettings(e.writerSettings),M.updateSettings(e.writerSettings),O(n,F,M)}function Z(e,n,s,i){if(n){const l=U(s,i,e.count);return new tt(s,i,l,e)}const c=H(e.buffer,e.stride/4,{originalIndices:s}),u=U(c.indices,i,c.uniqueCount);return{faces:c.indices,facesLength:c.indices.length,neighbors:u,vertices:j.createView(c.buffer)}}class tt{constructor(n,s,i,c){this.faces=n,this.facesLength=s,this.neighbors=i,this.vertices=c}}const F=new X,M=new Y,ht=R().vec3f("position0").vec3f("position1"),wt=R().vec3f("position0").vec3f("position1").u16("componentIndex");export{gt as extract,wt as extractComponentsEdgeLocationsLayout,Z as extractEdgeInformation,ht as extractEdgeLocationsLayout};
