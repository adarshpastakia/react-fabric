import{D as d,E as r,F as u,V as y,b as m,cb as b,K as f,B as F}from"./ShadowCastClear.glsl.js";import{n as P}from"./locationUtils.js";import{d as h,w as v,g as k}from"./parquet.js";let l=class extends d{constructor(n){super(n),this.type="location",this.latitudeFieldName=null,this.longitudeFieldName=null}};r([u({type:["location"],readOnly:!0,json:{write:!0}})],l.prototype,"type",void 0),r([u({json:{write:!0}})],l.prototype,"latitudeFieldName",void 0),r([u({json:{write:!0}})],l.prototype,"longitudeFieldName",void 0),l=r([y("esri.layers.support.ParquetEncodingLocation")],l);let a=class extends d{constructor(t){super(t),this.type="wkb",this.primaryFieldName=null}};r([u({type:["wkb"],readOnly:!0,json:{write:!0}})],a.prototype,"type",void 0),r([u({json:{write:!0}})],a.prototype,"orientation",void 0),r([u({json:{write:!0}})],a.prototype,"primaryFieldName",void 0),a=r([y("esri.layers.support.ParquetEncodingWkb")],a);const g=new F({esriGeometryPoint:"point",esriGeometryPolygon:"polygon",esriGeometryPolyline:"polyline",esriGeometryMultipoint:"multipoint"});function G(t){return g.toJSON(t)}function R(t){return g.fromJSON(t)}async function _(t,n={}){if(t.geometryType&&t.spatialReference&&t.encoding&&t.fields)return t;if(t.urls.length<1)throw new m("parquet:bad-input","At least one url must be specified",t);const o=await h(t.urls.getItemAt(0),{getCustomParameters:()=>n.customParameters}),i=v(o),e={...t,file:o};e.fields==null&&(e.fields=o.fields().map(s=>b.fromJSON({name:s.name,type:s.type}))),e.encoding==null&&(e.encoding=z(i,e.fields));const p=k(o);if(p)switch(p.mode){case"z":e.displayOptimization={mode:"z"};break;case"xz":{const s=p.multiscale;if(!s)throw new m("bad-format","XZ display optimization requires multiscale geometries");e.displayOptimization={mode:"xz",multiscale:s};break}}if(!e.encoding)return e;switch(e.encoding.type){case"location":e.spatialReference==null&&(e.spatialReference=f.WGS84),e.geometryType==null&&(e.geometryType="point");break;case"wkb":{if(!i)return e;const s=i.primary_column,c=i.columns[s];if(e.geometryType||(e.geometryType=j(c)),e.spatialReference||(e.spatialReference=x(c)),e.fields)for(const w of Object.keys(i.columns))e.fields=e.fields.filter(N=>N.name!==w)}}return e}function z(t,n){if(t!=null){const i=t.primary_column,e=t.columns[i];return new a({primaryFieldName:i,orientation:e.orientation??null})}const o=P(n.map(i=>i.name));return o.latitudeFieldName&&o.longitudeFieldName?new l({latitudeFieldName:o.latitudeFieldName,longitudeFieldName:o.longitudeFieldName}):null}function O(t){switch(t){case"Point":return"point";case"Polygon":case"MultiPolygon":return"polygon";case"LineString":return"polyline";case"MultiPoint":return"multipoint";default:return null}}function j(t){const{geometry_types:n}=t,o=new Set;for(const i of n){const e=O(i);e&&o.add(e)}if(o.size>1)throw new m("unsupported","Parquet mixed geometry types are not support",{geometryTypes:o});return o.size===1?o.values().next().value:void 0}function x(t){var o,i;const n=(i=(o=t.crs)==null?void 0:o.id)==null?void 0:i.code;return n&&typeof n=="number"?new f({wkid:n}):void 0}export{a,R as f,G as p,l as s,_ as y};
