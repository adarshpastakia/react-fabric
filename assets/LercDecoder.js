import{eZ as r}from"./ShadowCastClear.glsl.js";class d{constructor(e,t,s,a){this._hasNoDataValues=null,this._minValue=null,this._maxValue=null,"pixelData"in e?(this.values=e.pixelData,this.width=e.width,this.height=e.height,this.noDataValue=e.noDataValue):(this.values=e,this.width=t,this.height=s,this.noDataValue=a)}get hasNoDataValues(){if(this._hasNoDataValues==null){const e=this.noDataValue;this._hasNoDataValues=this.values.includes(e)}return this._hasNoDataValues}get minValue(){return this._ensureBounds(),this._minValue}get maxValue(){return this._ensureBounds(),this._maxValue}get usedMemory(){return this.values.byteLength+256}_ensureBounds(){if(this._minValue!=null)return;const{noDataValue:e,values:t}=this;let s=1/0,a=-1/0,h=!0;for(const i of t)i===e?this._hasNoDataValues=!0:(s=i<s?i:s,a=i>a?i:a,h=!1);h?(this._minValue=0,this._maxValue=0):(this._minValue=s,this._maxValue=a>-3e38?a:0)}}class n extends r{constructor(e=null){super("LercWorker","_decode",{_decode:t=>[t.buffer]},e,{strategy:"dedicated"}),this.schedule=e,this.ref=0}decode(e,t,s){return e&&e.byteLength!==0?this.invoke({buffer:e,options:t},s):Promise.resolve(null)}release(){--this.ref<=0&&(l.forEach((e,t)=>{e===this&&l.delete(t)}),this.destroy())}}const l=new Map;function V(u=null){let e=l.get(u);return e||(u!=null?(e=new n(t=>u.immediate.schedule(t)),l.set(u,e)):(e=new n,l.set(null,e))),++e.ref,e}export{d as a,V as s};
